// Buttplug Rust Source Code File - See https://buttplug.io for more info.
//
// Copyright 2016-2024 Nonpolynomial Labs LLC. All rights reserved.
//
// Licensed under the BSD 3-Clause license. See LICENSE file in the project root
// for full license information.

use crate::{
  core::{
    errors::ButtplugDeviceError,
    message::{Endpoint, LinearCmdV4},
  },
  server::device::{
    configuration::{ProtocolCommunicationSpecifier, UserDeviceDefinition, UserDeviceIdentifier},
    hardware::{Hardware, HardwareCommand, HardwareWriteCmd},
    protocol::{
      generic_protocol_initializer_setup, ProtocolHandler, ProtocolIdentifier, ProtocolInitializer,
    },
  },
  util::{async_manager, sleep},
};
use async_trait::async_trait;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::RwLock;

generic_protocol_initializer_setup!(Syncbot, "syncbot");

const CONTROL_LOOP_INTERVAL_MS: f64 = 50.0;

/// Encryption keys for Syncbot protocol.
/// These data are supposed to be generated by some Mersenne Twister algorithm,
/// but temporarily hardcoded here for simplicity.
/// For the device to work properly, data must be encrypted using an encryption
/// key that matches the provided frame ID. However, the validity of the frame ID
/// (for example, whether the value is consecutive with the previous frame ID)
/// does not seem to be verified, so in the future, it may be possible to simplify
/// the code by improving it so that a single frame ID is always used.
const ENCRYPT_KEYS: [u64; 256] = [
  0xeaa4b22321_u64,
  0x4376236d79_u64,
  0x3693c527ef_u64,
  0x196ceb2d04_u64,
  0xe5d4d9de34_u64,
  0x382f6aebcb_u64,
  0x3eb5c6ec4b_u64,
  0xe64dcff926_u64,
  0x485bb5d412_u64,
  0xc4e87d8548_u64,
  0x9b33441d66_u64,
  0x2c5715ec16_u64,
  0x3a5ba7def4_u64,
  0x28df05f982_u64,
  0xf258a0d6eb_u64,
  0x649c81f936_u64,
  0xbf44b642ad_u64,
  0x8962cda897_u64,
  0xaa8e31edb9_u64,
  0x2ecd8b260e_u64,
  0x0a0f6be951_u64,
  0x9d6c8dc558_u64,
  0xdc5e37ed52_u64,
  0x4927b1a36e_u64,
  0xb34de44204_u64,
  0x9abce8bba9_u64,
  0x2e7f111b0a_u64,
  0x2acebfb6c5_u64,
  0x2772115725_u64,
  0x149bbe5152_u64,
  0xfd3b0084b3_u64,
  0xe191a2d0c1_u64,
  0xe9d0745222_u64,
  0xdef3e5b8bd_u64,
  0x903595bbf6_u64,
  0x6a9ff6326b_u64,
  0x4249506621_u64,
  0xb54346bd96_u64,
  0x16a149533d_u64,
  0xf4b5d30ce4_u64,
  0x2abd219f50_u64,
  0xc383337e2c_u64,
  0x16af2701bd_u64,
  0x607d37bc81_u64,
  0xb456449167_u64,
  0x853f1affea_u64,
  0x132b176b16_u64,
  0x8ef721a346_u64,
  0xe74e6d9aa9_u64,
  0xe718edf7cf_u64,
  0xf2a3957afa_u64,
  0x9d47148231_u64,
  0x2daf165471_u64,
  0x7afa8581e0_u64,
  0x89bf1e7916_u64,
  0x30c53937a4_u64,
  0x851192eb0a_u64,
  0xc096427a91_u64,
  0x5cfe32a64a_u64,
  0xb063550785_u64,
  0x1fd7315482_u64,
  0x612d5b02bc_u64,
  0xcb406734cf_u64,
  0x4e00a22aa0_u64,
  0x3c7ebdd99f_u64,
  0xeeadfd24e3_u64,
  0xd481654de0_u64,
  0x5e6fecac60_u64,
  0x01a09d5e23_u64,
  0x77ba306ad4_u64,
  0xa72c443f51_u64,
  0xa909e5100a_u64,
  0x32ac12893d_u64,
  0xaa2264d6b1_u64,
  0xe47e2bf4df_u64,
  0xb60f165e43_u64,
  0x8062ed7d05_u64,
  0x31f0822837_u64,
  0x4d3d014bc0_u64,
  0xb65d4d6b96_u64,
  0x6035ae45e0_u64,
  0x9ec64725dc_u64,
  0x21db56c6ec_u64,
  0xb1754a7796_u64,
  0x253e68bce4_u64,
  0x3daacc9e6f_u64,
  0x12a1bd4a16_u64,
  0x9d42040c97_u64,
  0x82b94da1f8_u64,
  0xc68ea7fc5d_u64,
  0x61fea02774_u64,
  0xb63679131e_u64,
  0xdc7842ea43_u64,
  0xf760d0857b_u64,
  0x76f7108232_u64,
  0xb11f76de9b_u64,
  0x1b8beb0907_u64,
  0x306ccd0ca8_u64,
  0x1a95e06088_u64,
  0xb5b0611098_u64,
  0x17818007ce_u64,
  0xc76cec012f_u64,
  0x69ff96e6a7_u64,
  0x630182d98e_u64,
  0x487977e3d8_u64,
  0xf0999eeeb8_u64,
  0x1659fd9916_u64,
  0x19d485568d_u64,
  0x9c0a5f0c9a_u64,
  0x4e75bdb7f6_u64,
  0x2e271756ce_u64,
  0xa9b7e034e6_u64,
  0x2e38825822_u64,
  0xa72770d7f0_u64,
  0xf19936ed3b_u64,
  0xb8af755439_u64,
  0xa242d28229_u64,
  0x9e3934d2bb_u64,
  0x41b5bd69d3_u64,
  0x9b8125a66a_u64,
  0x5461dd765f_u64,
  0xf16f556194_u64,
  0x9b868665cf_u64,
  0x57ba87975d_u64,
  0x9eea30f987_u64,
  0x481a1cf930_u64,
  0xaec9e8628d_u64,
  0x07e6e6d4dc_u64,
  0x17472fb762_u64,
  0xf014274e03_u64,
  0x3b75b7f379_u64,
  0x2a8832ff75_u64,
  0xb14959e36b_u64,
  0x1d330d593b_u64,
  0x19d646be84_u64,
  0x1482344fe5_u64,
  0x80915b524c_u64,
  0x5e61b7a0a8_u64,
  0xfb62c49536_u64,
  0x4bc6d0ce2f_u64,
  0xbb415c8a13_u64,
  0x2254a4b6cf_u64,
  0xa3e0731b59_u64,
  0x205c2c488b_u64,
  0x3aa8a0c32a_u64,
  0x30ad4dd5a9_u64,
  0x5c998a28b5_u64,
  0xdb2bfa0283_u64,
  0x82e781c74d_u64,
  0xe7d5f3603c_u64,
  0x022eec6e51_u64,
  0x95026b3d0c_u64,
  0x3e653d351c_u64,
  0x392905ac24_u64,
  0x965978b897_u64,
  0x1ab807d243_u64,
  0x543e11fa3e_u64,
  0x4680f1b8d9_u64,
  0xb53a6b389b_u64,
  0x0b71d986f5_u64,
  0xa4caf35c3e_u64,
  0xc269806e24_u64,
  0xcfa1f1b014_u64,
  0x73edada2fe_u64,
  0x5af55238e0_u64,
  0xf368924c89_u64,
  0x87f0c2d1aa_u64,
  0xc41cd8ad8a_u64,
  0x22d6a50566_u64,
  0x1fb8f672e0_u64,
  0x3b39107003_u64,
  0x8aa36dd512_u64,
  0x3c245208aa_u64,
  0xeda0835116_u64,
  0x8affe667d1_u64,
  0x5d4df72acf_u64,
  0x532bcc7d6b_u64,
  0x8ac3b5aa92_u64,
  0x2208e5a7ac_u64,
  0x7cfe13cf09_u64,
  0xd9be4af091_u64,
  0xaf0e1d54cb_u64,
  0xf2efa82e3a_u64,
  0x2294e4e63e_u64,
  0x47fb68e879_u64,
  0xccc13181ff_u64,
  0x49a19635f5_u64,
  0x161c04655f_u64,
  0xb3da4eb17e_u64,
  0xbab85fad94_u64,
  0xde4466ae23_u64,
  0x9607f70e81_u64,
  0xf2351a3cf7_u64,
  0x8366b7ac16_u64,
  0x57d1c29760_u64,
  0x6042800860_u64,
  0xaa46dfecd3_u64,
  0x374ac8377e_u64,
  0x90f110f497_u64,
  0x8473dbeaeb_u64,
  0x3d06e6b3c9_u64,
  0xf21f9851bb_u64,
  0x83cbc8aa66_u64,
  0x7b7b3bc0e4_u64,
  0x0f9c5cffea_u64,
  0x1f9d8c9900_u64,
  0xa4e960e128_u64,
  0x1c86488edc_u64,
  0x3cecaa5083_u64,
  0x1f3400e93c_u64,
  0xc9fe579596_u64,
  0x91daba5713_u64,
  0xab95ed0aa4_u64,
  0x5ce00fd173_u64,
  0x32ad7ae4f6_u64,
  0x91dfc30ae3_u64,
  0x36b4c460ec_u64,
  0xc1f3e3c418_u64,
  0xbeeeeac6bd_u64,
  0xa2b90a08ba_u64,
  0x6dc569e612_u64,
  0xa1019ef3c3_u64,
  0x601ff398ee_u64,
  0x3684f70c5d_u64,
  0x277a4e6029_u64,
  0xb48ef9118d_u64,
  0x992fc25a2c_u64,
  0x10a74c0565_u64,
  0x369267c384_u64,
  0xe90143e730_u64,
  0x6d849acf40_u64,
  0x59f4fdba8e_u64,
  0x4a0d6aeda2_u64,
  0xaf4f858566_u64,
  0xbd11750ff2_u64,
  0x1ddfe385e2_u64,
  0xc6203516e2_u64,
  0x48707d5c5c_u64,
  0x5af8c9b04f_u64,
  0xcc052a6936_u64,
  0x96216e5cac_u64,
  0xaf841345c0_u64,
  0xcf687e18fc_u64,
  0xd500b37cd6_u64,
  0x83486caf7b_u64,
  0x382f768390_u64,
  0x528d1eeb8c_u64,
  0x4f3d0bdf5b_u64,
  0x1965e6e33a_u64,
  0xcacc42a327_u64,
  0xe95babda69_u64,
  0x849d916c2d_u64,
  0x189a24f9eb_u64,
  0x92ca2e5e54_u64,
  0xd628f05eea_u64,
  0x6e03b45305_u64,
];

#[derive(Default, Clone)]
pub struct SyncbotInitializer {}

#[async_trait]
impl ProtocolInitializer for SyncbotInitializer {
  async fn initialize(
    &mut self,
    hardware: Arc<Hardware>,
    _: &UserDeviceDefinition,
  ) -> Result<Arc<dyn ProtocolHandler>, ButtplugDeviceError> {
    hardware
      .write_value(&HardwareWriteCmd::new(
        Endpoint::Tx,
        // f0c82c000000000000000000000000000000e4
        vec![
          0xf0, 0xc8, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0xe4,
        ],
        false,
      ))
      .await?;
    Ok(Arc::new(Syncbot::new(hardware)))
  }
}

/// Generates the command data for the Syncbot protocol.
/// Protocol Format:
/// vec![
///   0xf0, // byte 0: signature
///   0xc9, // byte 1: signature
///   0x00, // byte 2: data (position; encrypted)
///   0x00, // byte 3: data (rotation; encrypted)
///   0x00, // byte 4: data (grip; encrypted)
///   0x00, // byte 5: data (unused?; encrypted)
///   0x00, // byte 6: checksum1 (sum of unencrypted bytes 2-5; encrypted)
///   0x00, // byte 7: null?
///   0x00, // byte 8: frame ID
///   0x00, // byte 9: encrypt key
///   0x00, // byte 10: encrypt key
///   0x00, // byte 11: encrypt key
///   0x00, // byte 12: encrypt key
///   0x00, // byte 13: encrypt key
///   0x00, // byte 14: null
///   0x00, // byte 15: null
///   0x00, // byte 16: null
///   0x00, // byte 17: null
///   0x00, // byte 18: checksum2 (sum of bytes 0-17)
/// ],
fn generate_command_data(command: [u8; 3], frame_id: u8) -> Vec<u8> {
  let data1: u8 = command[0];
  let data2: u8 = command[1];
  let data3: u8 = command[2];
  let data4: u8 = 0;
  let checksum1: u8 = ((data1 as u32 + data2 as u32 + data3 as u32 + data4 as u32) & 0xff) as u8;
  let encrypt_key = ENCRYPT_KEYS[frame_id as usize].to_be_bytes();
  let mut command_data: Vec<u8> = vec![
    0xf0,
    0xc9,
    data1 ^ encrypt_key[3],
    data2 ^ encrypt_key[4],
    data3 ^ encrypt_key[5],
    data4 ^ encrypt_key[6],
    checksum1 ^ encrypt_key[7],
    0x00,
    frame_id,
    encrypt_key[3],
    encrypt_key[4],
    encrypt_key[5],
    encrypt_key[6],
    encrypt_key[7],
    0x00,
    0x00,
    0x00,
    0x00,
  ];
  let checksum2: u8 = command_data.iter().fold(0u8, |acc, x| acc.wrapping_add(*x)) & 0xff;
  command_data.extend(&[checksum2]);
  command_data
}

async fn command_update_handler(device: Arc<Hardware>, syncbot: Syncbot) {
  debug!("Entering Syncbot Control Loop");
  let mut current_command = syncbot.current_command.read().await.clone();
  let mut frame_id = 0_u8;
  while device
    .write_value(&HardwareWriteCmd::new(
      Endpoint::Tx,
      generate_command_data(current_command, frame_id),
      false,
    ))
    .await
    .is_ok()
  {
    sleep(Duration::from_millis(CONTROL_LOOP_INTERVAL_MS as u64)).await;
    frame_id = frame_id.wrapping_add(1);
    let current_position = syncbot.current_position.read().await.clone();
    let target_position = syncbot.target_position.read().await.clone();
    let position_speed = syncbot.position_speed.read().await.clone();
    if current_position < target_position {
      let mut new_position = current_position + position_speed * CONTROL_LOOP_INTERVAL_MS;
      if new_position > target_position {
        new_position = target_position;
      }
      let mut current_position = syncbot.current_position.write().await;
      *current_position = new_position;
    } else if current_position > target_position {
      let mut new_position = current_position - position_speed * CONTROL_LOOP_INTERVAL_MS;
      if new_position < target_position {
        new_position = target_position;
      }
      let mut current_position = syncbot.current_position.write().await;
      *current_position = new_position;
    }
    current_command = syncbot.current_command.write().await.clone();
    current_command[0] = current_position as u8;
    trace!("Syncbot Command: {:?}", current_command);
  }
  info!("Syncbot control loop exiting, most likely due to device disconnection.");
}

#[derive(Default, Clone)]
pub struct Syncbot {
  current_command: Arc<RwLock<[u8; 3]>>,
  current_position: Arc<RwLock<f64>>,
  target_position: Arc<RwLock<f64>>,
  position_speed: Arc<RwLock<f64>>,
}

impl Syncbot {
  pub fn new(device: Arc<Hardware>) -> Self {
    let syncbot = Self {
      current_command: Arc::new(RwLock::new([0, 128, 128])),
      current_position: Arc::new(RwLock::new(0.0)),
      target_position: Arc::new(RwLock::new(0.0)),
      position_speed: Arc::new(RwLock::new(0.0)),
    };
    let syncbot_clone = syncbot.clone();
    async_manager::spawn(async move { command_update_handler(device, syncbot_clone).await });
    syncbot
  }
}

impl ProtocolHandler for Syncbot {
  fn handle_linear_cmd(
    &self,
    message: LinearCmdV4,
  ) -> Result<Vec<HardwareCommand>, ButtplugDeviceError> {
    debug!("Syncbot: Handling linear command: {:?}", message);
    let vector = message.vectors()[0].clone();
    let position = vector.position() * 255f64;
    let duration = vector.duration() as f64;
    let current_position = self.current_position.clone();
    let position_speed = self.position_speed.clone();
    let target_position = self.target_position.clone();
    async_manager::spawn(async move {
      let current_position = current_position.read().await;
      let speed = (position - *current_position).abs() / duration;
      let mut position_speed = position_speed.write().await;
      *position_speed = speed;
      let mut target_position = target_position.write().await;
      *target_position = position;
    });
    Ok(vec![])
  }

  fn handle_rotate_cmd(
    &self,
    cmds: &[Option<(u32, bool)>],
  ) -> Result<Vec<HardwareCommand>, ButtplugDeviceError> {
    debug!("Syncbot: Handling rotate command: {:?}", cmds);
    if let Some((speed, clockwise)) = cmds[0] {
      let current_command = self.current_command.clone();
      let rotate_byte = if clockwise {
        128_u8 + speed as u8
      } else {
        128_u8 - speed as u8
      };
      async_manager::spawn(async move {
        let mut command_writer = current_command.write().await;
        command_writer[1] = rotate_byte;
      });
    }
    Ok(vec![])
  }

  fn handle_scalar_oscillate_cmd(
    &self,
    _index: u32,
    scalar: u32,
  ) -> Result<Vec<HardwareCommand>, ButtplugDeviceError> {
    debug!("Syncbot: Handling oscillate command: {:?}", scalar);
    let current_command = self.current_command.clone();
    // Gripping into negative direction is currently not supported
    let oscillate_byte = 128_u8 + scalar as u8;
    async_manager::spawn(async move {
      let mut command_writer = current_command.write().await;
      command_writer[2] = oscillate_byte;
    });
    Ok(vec![])
  }
}
