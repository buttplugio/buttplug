// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HampState {
    #[prost(enumeration = "HampPlayState", tag = "1")]
    pub play_state: i32,
    #[prost(float, tag = "2")]
    pub velocity: f32,
    /// Forward = false, Backward = true. Can be different on future models. No logic to convert if changed in the driver
    #[prost(bool, tag = "3")]
    pub direction: bool,
    /// \[0-1\] Min position in % - Added in FW4.0.15
    #[prost(float, tag = "4")]
    pub min: f32,
    /// \[0-1\] Max position in % - Added in FW4.0.15
    #[prost(float, tag = "5")]
    pub max: f32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HrppPattern {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Max 16 characters
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// NB! uint8 on system
    #[prost(uint32, tag = "3")]
    pub version: u32,
    #[prost(bool, tag = "4")]
    pub custom_pattern: bool,
    /// NB! uint8 on system
    #[prost(uint32, tag = "5")]
    pub slot: u32,
    #[prost(enumeration = "HrppPatternType", tag = "6")]
    pub r#type: i32,
    /// NB! uint16 on system
    #[prost(uint32, tag = "7")]
    pub pause_random_min: u32,
    /// NB! uint16 on system
    #[prost(uint32, tag = "8")]
    pub pause_random_max: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HrppState {
    /// NB! uint8 on system
    #[prost(uint32, tag = "1")]
    pub current_pattern_nr: u32,
    #[prost(message, optional, tag = "2")]
    pub current_pattern: ::core::option::Option<HrppPattern>,
    /// NB! uint8 on system
    #[prost(uint32, tag = "3")]
    pub nr_of_patterns: u32,
    #[prost(bool, tag = "4")]
    pub enabled: bool,
    #[prost(float, tag = "5")]
    pub amplitude: f32,
    #[prost(float, tag = "6")]
    pub playback_speed: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HspState {
    #[prost(enumeration = "HspPlayState", tag = "1")]
    pub play_state: i32,
    /// points in the buffer
    #[prost(uint32, tag = "2")]
    pub points: u32,
    /// Max nr of points in the buffer - depends on the device
    #[prost(uint32, tag = "3")]
    pub max_points: u32,
    /// the current index to the point playing (NB! will be -1 in the response to a play command)
    #[prost(int32, tag = "4")]
    pub current_point: i32,
    /// the current time playing
    #[prost(int32, tag = "5")]
    pub current_time: i32,
    /// true if the buffer is looping after the last point
    #[prost(bool, tag = "6")]
    pub r#loop: bool,
    /// the current playback rate
    #[prost(float, tag = "7")]
    pub playback_rate: f32,
    /// time of the first point in the buffer
    #[prost(uint32, tag = "8")]
    pub first_point_time: u32,
    /// time of the last point in the buffer
    #[prost(uint32, tag = "9")]
    pub last_point_time: u32,
    /// the stream id of the current stream
    #[prost(uint32, tag = "10")]
    pub stream_id: u32,
    /// the current point playing - will be -1 when playingAbsoluteIndex
    #[prost(int32, tag = "11")]
    pub tail_point_stream_index: i32,
    /// When to trigger a threshold notification
    #[prost(uint32, tag = "12")]
    pub tail_point_stream_index_threshold: u32,
    /// \[Default false\] If true, the stream will pause when the buffer is empty. When data is added the stream will resume without time adjustments
    #[prost(bool, tag = "13")]
    pub pause_on_starving: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HvpState {
    /// If the vibration is started/active
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// 0-1 (0-100%) For LRA, ERM and Sliders with vibration adapter (percent of valid output range)
    #[prost(float, tag = "2")]
    pub amplitude: f32,
    /// 0-10000 (Hz) For LRA only
    #[prost(uint32, tag = "3")]
    pub frequency: u32,
    /// (mm) Where on the slider should the vibration be. For slider with vibration adapter only.
    #[prost(float, tag = "4")]
    pub position: f32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Point {
    #[prost(uint32, tag = "1")]
    pub t: u32,
    /// uint8 0-255 max!
    #[prost(uint32, tag = "2")]
    pub x: u32,
}
///
/// Can be extended with more info from wifi_ap_record_t if need:
/// typedef struct {
/// uint8_t bssid\[6\];                     //< MAC address of AP
/// uint8_t ssid\[33\];                     //< SSID of AP
/// uint8_t primary;                      //< channel of AP
/// wifi_second_chan_t second;            //< secondary channel of AP
/// int8_t  rssi;                         //< signal strength of AP
/// wifi_auth_mode_t authmode;            //< authmode of AP
/// wifi_cipher_type_t pairwise_cipher;   //< pairwise cipher of AP
/// wifi_cipher_type_t group_cipher;      //< group cipher of AP
/// wifi_ant_t ant;                       //< antenna used to receive beacon from AP
/// uint32_t phy_11b:1;                   //< bit: 0 flag to identify if 11b mode is enabled or not
/// uint32_t phy_11g:1;                   //< bit: 1 flag to identify if 11g mode is enabled or not
/// uint32_t phy_11n:1;                   //< bit: 2 flag to identify if 11n mode is enabled or not
/// uint32_t phy_lr:1;                    //< bit: 3 flag to identify if low rate is enabled or not
/// uint32_t phy_11ax:1;                  //< bit: 4 flag to identify if 11ax mode is enabled or not
/// uint32_t wps:1;                       //< bit: 5 flag to identify if WPS is supported or not
/// uint32_t ftm_responder:1;             //< bit: 6 flag to identify if FTM is supported in responder mode
/// uint32_t ftm_initiator:1;             //< bit: 7 flag to identify if FTM is supported in initiator mode
/// uint32_t reserved:24;                 //< bit: 8..31 reserved
/// wifi_country_t country;               //< country information of AP
/// wifi_he_ap_info_t he_ap;              //< HE AP info
/// } wifi_ap_record_t;
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApInfo {
    #[prost(string, tag = "1")]
    pub ssid: ::prost::alloc::string::String,
    /// MAC address of AP
    #[prost(string, tag = "2")]
    pub bssid: ::prost::alloc::string::String,
    /// \[int8\] 0-255 max!
    #[prost(uint32, tag = "3")]
    pub channel: u32,
    #[prost(enumeration = "AuthModes", tag = "4")]
    pub authmode: i32,
    /// \[int8\] -128 - 127
    #[prost(int32, tag = "5")]
    pub rssi: i32,
    /// IP address of Handy only for connected AP (not scan results)
    #[prost(string, tag = "6")]
    pub ip: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatteryState {
    /// 0-100
    #[prost(uint32, tag = "1")]
    pub level: u32,
    #[prost(bool, tag = "2")]
    pub charger_connected: bool,
    #[prost(bool, tag = "3")]
    pub charging_complete: bool,
    /// in V
    #[prost(float, tag = "4")]
    pub usb_voltage: f32,
    /// in V
    #[prost(float, tag = "5")]
    pub battery_voltage: f32,
    /// 0-4095
    #[prost(uint32, tag = "6")]
    pub usb_adc_value: u32,
    /// 0-4095
    #[prost(uint32, tag = "7")]
    pub battery_adc_value: u32,
    /// in C //Added in FW 4.0.16
    #[prost(float, tag = "8")]
    pub battery_temperature: f32,
    /// 0-4095 //Added in FW 4.0.16
    #[prost(uint32, tag = "9")]
    pub battery_temperature_adc_value: u32,
    /// Handy 2 only - If the charger is not supported by the device (ex: <15V) - Added in FW 4.0.16
    #[prost(bool, tag = "10")]
    pub not_supported_charger: bool,
    /// If the device is shutting down due to low battery voltage - Added in FW 4.0.16
    #[prost(bool, tag = "11")]
    pub shut_down_voltage_detected: bool,
    /// Handy 2 only - If the charger is faulty (Most likely high temperature) - Added in FW 4.0.16
    #[prost(bool, tag = "12")]
    pub charger_fault_detected: bool,
    /// \[V\] when the charger cut of last time. Used as a reference for 100% battery voltage - Added in FW 4.0.19
    #[prost(float, tag = "13")]
    pub last_fully_charged_voltage: f32,
    /// IC chgr status - only OH - Added in FW 4.0.19
    #[prost(bool, tag = "14")]
    pub chgr: bool,
    /// IC done status - only OH - Added in FW 4.0.19
    #[prost(bool, tag = "15")]
    pub ic_done: bool,
    /// Power good status - only H2 - Added in FW 4.0.19
    #[prost(bool, tag = "16")]
    pub pg: bool,
    /// Only H2 (and future Oh versions) - Charger is disabled due to battery full - Added in FW 4.0.19
    #[prost(bool, tag = "17")]
    pub charger_disabled: bool,
    /// Charger is charging the battery - Added in FW 4.0.19
    #[prost(bool, tag = "18")]
    pub charging: bool,
}
/// NB! The codes are not in order, but in groups
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HandyErrorCodes {
    /// DO NOT USE - 0 is ESP_OK -> only here for proto legacy compatibility
    HandyErrorCodeProto2LegacyCompDoNotUse = 0,
    ErrorUnknownRequestType = 100000,
    ErrorUnknownResponseType = 100001,
    ErrorUnknownCommand = 100002,
    ErrorNotImplemented = 100003,
    /// This will rearly never trigger, since FW4 will set the correct mode
    ErrorWrongMode = 100004,
    /// Motor temp high - slider only
    ErrorTempHigh = 100005,
    /// Slider only
    ErrorSliderBlocked = 100006,
    /// When there is a unknown error with the mode controller. Should not happen, but might be some sloopy coding
    ErrorUnknownModeError = 100007,
    /// server time not synced with on Handy
    ErrorTimeNotSynced = 100008,
    /// Network delay is negative -> Some time syncing is not correct
    ErrorNegativeNetworkDelay = 100009,
    /// Message size is too big. Max size is 1024 bytes (subject to change)
    ErrorMessageSizeTooBig = 100010,
    /// Machine is not connected
    ErrorMessageNotConnected = 100011,
    /// Generic server error
    ErrorMessageGenericServerError = 100012,
    /// Message queue is full
    ErrorMessageQueueFull = 100014,
    /// OTA is started -> mode change is not allowed
    ErrorOtaStarted = 100013,
    /// OTA write failure
    ErrorOtaQueueWriteFailure = 100015,
    /// OTA error (any error)
    ErrorOtaError = 100016,
    /// Failed to allocate memory for OTA chunk
    ErrorOtaMemError = 100024,
    /// OTA has not started -> OTA is not allowed to proceed
    ErrorOtaNotStarted = 100025,
    /// Function not supported (Ex: Slider function calls on a LRA product)
    ErrorFunctionNotSupported = 100017,
    /// RPC message pool is full
    ErrorRpcMsgPoolFull = 100019,
    /// Failed to unpack the RPC message
    ErrorRpcFailedToUnpack = 100020,
    /// RPC is not allowed with this transport mode
    ErrorRpcNotAllowedWithThisTransportMode = 100021,
    /// Network delay is too big. Max allowed is 24h == 86400s == 86400000ms
    ErrorRpcNetworkDelayTooBig = 100022,
    /// RPC is not initialized -> RPC is not allowed to proceed - Added in FW 4.0.16
    ErrorRpcNotInitialized = 100029,
    /// RPC handler queue is full -> RPC is not allowed to proceed - Added in FW 4.0.16
    ErrorRpcHandlerQueueFull = 100030,
    /// RPC send timeout (5s) -> RPC is not allowed to proceed - Added in FW 4.0.16
    ErrorRpcSendTimeout = 100031,
    /// Generic error - ESP_FAIL -> This will be converted to this error - ESP_FAIL is -1, negative values are not supported
    ErrorFail = 100023,
    /// Hall sensor error
    ErrorHallSensorError = 100026,
    /// Added in 4.0.15 - Overclocking is not supported on this device
    ErrorOverclockingNotSupported = 100027,
    /// Added in 4.0.15 - Trying to overclock, but overclocking is not enabled in the FW
    ErrorOverclockingIsNotEnabled = 100028,
    /// When in mode DISABLED, mode change is not allowed. - Added in FW 4.0.16
    ErrorModeChangeNotAllowedWhenDisabled = 100032,
    /// Power OTA errors
    ErrorOtaErrNoOtaPartition = 200001,
    ErrorOtaErrInvalidBin = 20000,
    ErrorOtaErrInvalidParam = 200003,
    /// The OTA has been successfull, but during the new FW failed to boot correctly the first boot and has been flagged as invalid
    ErrorOtaErrNewOtaHasPreviouslyFailed = 200004,
    /// The new OTA is the same as the current running FW
    ErrorOtaErrNewOtaSameAsCurrent = 200005,
}
impl HandyErrorCodes {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HandyErrorCodeProto2LegacyCompDoNotUse => {
                "HANDY_ERROR_CODE_PROTO2_LEGACY_COMP_DO_NOT_USE"
            }
            Self::ErrorUnknownRequestType => "ERROR_UNKNOWN_REQUEST_TYPE",
            Self::ErrorUnknownResponseType => "ERROR_UNKNOWN_RESPONSE_TYPE",
            Self::ErrorUnknownCommand => "ERROR_UNKNOWN_COMMAND",
            Self::ErrorNotImplemented => "ERROR_NOT_IMPLEMENTED",
            Self::ErrorWrongMode => "ERROR_WRONG_MODE",
            Self::ErrorTempHigh => "ERROR_TEMP_HIGH",
            Self::ErrorSliderBlocked => "ERROR_SLIDER_BLOCKED",
            Self::ErrorUnknownModeError => "ERROR_UNKNOWN_MODE_ERROR",
            Self::ErrorTimeNotSynced => "ERROR_TIME_NOT_SYNCED",
            Self::ErrorNegativeNetworkDelay => "ERROR_NEGATIVE_NETWORK_DELAY",
            Self::ErrorMessageSizeTooBig => "ERROR_MESSAGE_SIZE_TOO_BIG",
            Self::ErrorMessageNotConnected => "ERROR_MESSAGE_NOT_CONNECTED",
            Self::ErrorMessageGenericServerError => "ERROR_MESSAGE_GENERIC_SERVER_ERROR",
            Self::ErrorMessageQueueFull => "ERROR_MESSAGE_QUEUE_FULL",
            Self::ErrorOtaStarted => "ERROR_OTA_STARTED",
            Self::ErrorOtaQueueWriteFailure => "ERROR_OTA_QUEUE_WRITE_FAILURE",
            Self::ErrorOtaError => "ERROR_OTA_ERROR",
            Self::ErrorOtaMemError => "ERROR_OTA_MEM_ERROR",
            Self::ErrorOtaNotStarted => "ERROR_OTA_NOT_STARTED",
            Self::ErrorFunctionNotSupported => "ERROR_FUNCTION_NOT_SUPPORTED",
            Self::ErrorRpcMsgPoolFull => "ERROR_RPC_MSG_POOL_FULL",
            Self::ErrorRpcFailedToUnpack => "ERROR_RPC_FAILED_TO_UNPACK",
            Self::ErrorRpcNotAllowedWithThisTransportMode => {
                "ERROR_RPC_NOT_ALLOWED_WITH_THIS_TRANSPORT_MODE"
            }
            Self::ErrorRpcNetworkDelayTooBig => "ERROR_RPC_NETWORK_DELAY_TOO_BIG",
            Self::ErrorRpcNotInitialized => "ERROR_RPC_NOT_INITIALIZED",
            Self::ErrorRpcHandlerQueueFull => "ERROR_RPC_HANDLER_QUEUE_FULL",
            Self::ErrorRpcSendTimeout => "ERROR_RPC_SEND_TIMEOUT",
            Self::ErrorFail => "ERROR_FAIL",
            Self::ErrorHallSensorError => "ERROR_HALL_SENSOR_ERROR",
            Self::ErrorOverclockingNotSupported => "ERROR_OVERCLOCKING_NOT_SUPPORTED",
            Self::ErrorOverclockingIsNotEnabled => "ERROR_OVERCLOCKING_IS_NOT_ENABLED",
            Self::ErrorModeChangeNotAllowedWhenDisabled => {
                "ERROR_MODE_CHANGE_NOT_ALLOWED_WHEN_DISABLED"
            }
            Self::ErrorOtaErrNoOtaPartition => "ERROR_OTA_ERR_NO_OTA_PARTITION",
            Self::ErrorOtaErrInvalidBin => "ERROR_OTA_ERR_INVALID_BIN",
            Self::ErrorOtaErrInvalidParam => "ERROR_OTA_ERR_INVALID_PARAM",
            Self::ErrorOtaErrNewOtaHasPreviouslyFailed => {
                "ERROR_OTA_ERR_NEW_OTA_HAS_PREVIOUSLY_FAILED"
            }
            Self::ErrorOtaErrNewOtaSameAsCurrent => {
                "ERROR_OTA_ERR_NEW_OTA_SAME_AS_CURRENT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HANDY_ERROR_CODE_PROTO2_LEGACY_COMP_DO_NOT_USE" => {
                Some(Self::HandyErrorCodeProto2LegacyCompDoNotUse)
            }
            "ERROR_UNKNOWN_REQUEST_TYPE" => Some(Self::ErrorUnknownRequestType),
            "ERROR_UNKNOWN_RESPONSE_TYPE" => Some(Self::ErrorUnknownResponseType),
            "ERROR_UNKNOWN_COMMAND" => Some(Self::ErrorUnknownCommand),
            "ERROR_NOT_IMPLEMENTED" => Some(Self::ErrorNotImplemented),
            "ERROR_WRONG_MODE" => Some(Self::ErrorWrongMode),
            "ERROR_TEMP_HIGH" => Some(Self::ErrorTempHigh),
            "ERROR_SLIDER_BLOCKED" => Some(Self::ErrorSliderBlocked),
            "ERROR_UNKNOWN_MODE_ERROR" => Some(Self::ErrorUnknownModeError),
            "ERROR_TIME_NOT_SYNCED" => Some(Self::ErrorTimeNotSynced),
            "ERROR_NEGATIVE_NETWORK_DELAY" => Some(Self::ErrorNegativeNetworkDelay),
            "ERROR_MESSAGE_SIZE_TOO_BIG" => Some(Self::ErrorMessageSizeTooBig),
            "ERROR_MESSAGE_NOT_CONNECTED" => Some(Self::ErrorMessageNotConnected),
            "ERROR_MESSAGE_GENERIC_SERVER_ERROR" => {
                Some(Self::ErrorMessageGenericServerError)
            }
            "ERROR_MESSAGE_QUEUE_FULL" => Some(Self::ErrorMessageQueueFull),
            "ERROR_OTA_STARTED" => Some(Self::ErrorOtaStarted),
            "ERROR_OTA_QUEUE_WRITE_FAILURE" => Some(Self::ErrorOtaQueueWriteFailure),
            "ERROR_OTA_ERROR" => Some(Self::ErrorOtaError),
            "ERROR_OTA_MEM_ERROR" => Some(Self::ErrorOtaMemError),
            "ERROR_OTA_NOT_STARTED" => Some(Self::ErrorOtaNotStarted),
            "ERROR_FUNCTION_NOT_SUPPORTED" => Some(Self::ErrorFunctionNotSupported),
            "ERROR_RPC_MSG_POOL_FULL" => Some(Self::ErrorRpcMsgPoolFull),
            "ERROR_RPC_FAILED_TO_UNPACK" => Some(Self::ErrorRpcFailedToUnpack),
            "ERROR_RPC_NOT_ALLOWED_WITH_THIS_TRANSPORT_MODE" => {
                Some(Self::ErrorRpcNotAllowedWithThisTransportMode)
            }
            "ERROR_RPC_NETWORK_DELAY_TOO_BIG" => Some(Self::ErrorRpcNetworkDelayTooBig),
            "ERROR_RPC_NOT_INITIALIZED" => Some(Self::ErrorRpcNotInitialized),
            "ERROR_RPC_HANDLER_QUEUE_FULL" => Some(Self::ErrorRpcHandlerQueueFull),
            "ERROR_RPC_SEND_TIMEOUT" => Some(Self::ErrorRpcSendTimeout),
            "ERROR_FAIL" => Some(Self::ErrorFail),
            "ERROR_HALL_SENSOR_ERROR" => Some(Self::ErrorHallSensorError),
            "ERROR_OVERCLOCKING_NOT_SUPPORTED" => {
                Some(Self::ErrorOverclockingNotSupported)
            }
            "ERROR_OVERCLOCKING_IS_NOT_ENABLED" => {
                Some(Self::ErrorOverclockingIsNotEnabled)
            }
            "ERROR_MODE_CHANGE_NOT_ALLOWED_WHEN_DISABLED" => {
                Some(Self::ErrorModeChangeNotAllowedWhenDisabled)
            }
            "ERROR_OTA_ERR_NO_OTA_PARTITION" => Some(Self::ErrorOtaErrNoOtaPartition),
            "ERROR_OTA_ERR_INVALID_BIN" => Some(Self::ErrorOtaErrInvalidBin),
            "ERROR_OTA_ERR_INVALID_PARAM" => Some(Self::ErrorOtaErrInvalidParam),
            "ERROR_OTA_ERR_NEW_OTA_HAS_PREVIOUSLY_FAILED" => {
                Some(Self::ErrorOtaErrNewOtaHasPreviouslyFailed)
            }
            "ERROR_OTA_ERR_NEW_OTA_SAME_AS_CURRENT" => {
                Some(Self::ErrorOtaErrNewOtaSameAsCurrent)
            }
            _ => None,
        }
    }
}
/// /////////////////////// Mode related constants /////////////////////////
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Mode {
    Hamp = 0,
    Hssp = 1,
    Hdsp = 2,
    Maintenance = 3,
    Hsp = 4,
    Ota = 5,
    /// Nothing happens on the device. Button presses are sent as notifications
    Button = 6,
    /// Nothing is running -> when changing online mode this state is set to allocated correct memory pool in mode (HSP)
    Idle = 7,
    Hvp = 8,
    Hrpp = 9,
    /// Nothing works in this mode. Mode change is not possible externally or from buttons. Can only be set in the FW, not externally. Used before shutdown or in critical errors. - Added in FW 4.0.16
    Disabled = 10,
}
impl Mode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Hamp => "MODE_HAMP",
            Self::Hssp => "MODE_HSSP",
            Self::Hdsp => "MODE_HDSP",
            Self::Maintenance => "MODE_MAINTENANCE",
            Self::Hsp => "MODE_HSP",
            Self::Ota => "MODE_OTA",
            Self::Button => "MODE_BUTTON",
            Self::Idle => "MODE_IDLE",
            Self::Hvp => "MODE_HVP",
            Self::Hrpp => "MODE_HRPP",
            Self::Disabled => "MODE_DISABLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MODE_HAMP" => Some(Self::Hamp),
            "MODE_HSSP" => Some(Self::Hssp),
            "MODE_HDSP" => Some(Self::Hdsp),
            "MODE_MAINTENANCE" => Some(Self::Maintenance),
            "MODE_HSP" => Some(Self::Hsp),
            "MODE_OTA" => Some(Self::Ota),
            "MODE_BUTTON" => Some(Self::Button),
            "MODE_IDLE" => Some(Self::Idle),
            "MODE_HVP" => Some(Self::Hvp),
            "MODE_HRPP" => Some(Self::Hrpp),
            "MODE_DISABLED" => Some(Self::Disabled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HampPlayState {
    HampStateStopped = 0,
    HampStateRunning = 1,
}
impl HampPlayState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HampStateStopped => "HAMP_STATE_STOPPED",
            Self::HampStateRunning => "HAMP_STATE_RUNNING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HAMP_STATE_STOPPED" => Some(Self::HampStateStopped),
            "HAMP_STATE_RUNNING" => Some(Self::HampStateRunning),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HrppPatternType {
    HrppNotSet = 0,
    HrppScript = 1,
    HrppWave = 2,
}
impl HrppPatternType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HrppNotSet => "HRPP_NOT_SET",
            Self::HrppScript => "HRPP_SCRIPT",
            Self::HrppWave => "HRPP_WAVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HRPP_NOT_SET" => Some(Self::HrppNotSet),
            "HRPP_SCRIPT" => Some(Self::HrppScript),
            "HRPP_WAVE" => Some(Self::HrppWave),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HdspPlayState {
    HdspStateStopped = 0,
    /// NB! Very short window that the state is MOVING
    HdspStateMoving = 1,
    HdspStateReached = 2,
}
impl HdspPlayState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HdspStateStopped => "HDSP_STATE_STOPPED",
            Self::HdspStateMoving => "HDSP_STATE_MOVING",
            Self::HdspStateReached => "HDSP_STATE_REACHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HDSP_STATE_STOPPED" => Some(Self::HdspStateStopped),
            "HDSP_STATE_MOVING" => Some(Self::HdspStateMoving),
            "HDSP_STATE_REACHED" => Some(Self::HdspStateReached),
            _ => None,
        }
    }
}
/// /////////////////////// HSP constants /////////////////////////
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HspPlayState {
    HspStateNotInitialized = 0,
    HspStatePlaying = 1,
    HspStateStopped = 2,
    HspStatePaused = 3,
    HspStateStarving = 4,
}
impl HspPlayState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HspStateNotInitialized => "HSP_STATE_NOT_INITIALIZED",
            Self::HspStatePlaying => "HSP_STATE_PLAYING",
            Self::HspStateStopped => "HSP_STATE_STOPPED",
            Self::HspStatePaused => "HSP_STATE_PAUSED",
            Self::HspStateStarving => "HSP_STATE_STARVING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HSP_STATE_NOT_INITIALIZED" => Some(Self::HspStateNotInitialized),
            "HSP_STATE_PLAYING" => Some(Self::HspStatePlaying),
            "HSP_STATE_STOPPED" => Some(Self::HspStateStopped),
            "HSP_STATE_PAUSED" => Some(Self::HspStatePaused),
            "HSP_STATE_STARVING" => Some(Self::HspStateStarving),
            _ => None,
        }
    }
}
/// /////////////////////// Button constants /////////////////////////
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Button {
    On = 0,
    Up = 1,
    Left = 2,
    Right = 3,
    Down = 4,
    Wifi = 5,
}
impl Button {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::On => "BUTTON_ON",
            Self::Up => "BUTTON_UP",
            Self::Left => "BUTTON_LEFT",
            Self::Right => "BUTTON_RIGHT",
            Self::Down => "BUTTON_DOWN",
            Self::Wifi => "BUTTON_WIFI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUTTON_ON" => Some(Self::On),
            "BUTTON_UP" => Some(Self::Up),
            "BUTTON_LEFT" => Some(Self::Left),
            "BUTTON_RIGHT" => Some(Self::Right),
            "BUTTON_DOWN" => Some(Self::Down),
            "BUTTON_WIFI" => Some(Self::Wifi),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ButtonEvent {
    /// NOT IN USE
    Pressed = 0,
    /// NOT IN USE
    Released = 1,
    Shortpress = 2,
    LongpressStart = 3,
    LongpressStep = 4,
    LongpressStop = 5,
}
impl ButtonEvent {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Pressed => "BUTTON_EVENT_PRESSED",
            Self::Released => "BUTTON_EVENT_RELEASED",
            Self::Shortpress => "BUTTON_EVENT_SHORTPRESS",
            Self::LongpressStart => "BUTTON_EVENT_LONGPRESS_START",
            Self::LongpressStep => "BUTTON_EVENT_LONGPRESS_STEP",
            Self::LongpressStop => "BUTTON_EVENT_LONGPRESS_STOP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUTTON_EVENT_PRESSED" => Some(Self::Pressed),
            "BUTTON_EVENT_RELEASED" => Some(Self::Released),
            "BUTTON_EVENT_SHORTPRESS" => Some(Self::Shortpress),
            "BUTTON_EVENT_LONGPRESS_START" => Some(Self::LongpressStart),
            "BUTTON_EVENT_LONGPRESS_STEP" => Some(Self::LongpressStep),
            "BUTTON_EVENT_LONGPRESS_STOP" => Some(Self::LongpressStop),
            _ => None,
        }
    }
}
///
/// Excact copy of ESP_IDF wifi_auth_mode_t
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthModes {
    AuthOpen = 0,
    AuthWep = 1,
    AuthWpaPsk = 2,
    AuthWpa2Psk = 3,
    AuthWpaWpa2Psk = 4,
    AuthWpa2Enterprise = 5,
    AuthWpa3Psk = 6,
    AuthWpa2Wpa3Psk = 7,
    AuthWapiPsk = 8,
    AuthOwe = 9,
    AuthMax = 10,
}
impl AuthModes {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AuthOpen => "AUTH_OPEN",
            Self::AuthWep => "AUTH_WEP",
            Self::AuthWpaPsk => "AUTH_WPA_PSK",
            Self::AuthWpa2Psk => "AUTH_WPA2_PSK",
            Self::AuthWpaWpa2Psk => "AUTH_WPA_WPA2_PSK",
            Self::AuthWpa2Enterprise => "AUTH_WPA2_ENTERPRISE",
            Self::AuthWpa3Psk => "AUTH_WPA3_PSK",
            Self::AuthWpa2Wpa3Psk => "AUTH_WPA2_WPA3_PSK",
            Self::AuthWapiPsk => "AUTH_WAPI_PSK",
            Self::AuthOwe => "AUTH_OWE",
            Self::AuthMax => "AUTH_MAX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTH_OPEN" => Some(Self::AuthOpen),
            "AUTH_WEP" => Some(Self::AuthWep),
            "AUTH_WPA_PSK" => Some(Self::AuthWpaPsk),
            "AUTH_WPA2_PSK" => Some(Self::AuthWpa2Psk),
            "AUTH_WPA_WPA2_PSK" => Some(Self::AuthWpaWpa2Psk),
            "AUTH_WPA2_ENTERPRISE" => Some(Self::AuthWpa2Enterprise),
            "AUTH_WPA3_PSK" => Some(Self::AuthWpa3Psk),
            "AUTH_WPA2_WPA3_PSK" => Some(Self::AuthWpa2Wpa3Psk),
            "AUTH_WAPI_PSK" => Some(Self::AuthWapiPsk),
            "AUTH_OWE" => Some(Self::AuthOwe),
            "AUTH_MAX" => Some(Self::AuthMax),
            _ => None,
        }
    }
}
/// Matches hdyWifiConnectionStatus_t (does not matches the legacy protobuf enum from espresif)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WifiState {
    Disconnected = 0,
    Connected = 1,
    Connecting = 2,
    Reconnecting = 3,
    /// or reconnecting
    FailedToConnect = 4,
    Disconnecting = 5,
}
impl WifiState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Disconnected => "WIFI_STATE_DISCONNECTED",
            Self::Connected => "WIFI_STATE_CONNECTED",
            Self::Connecting => "WIFI_STATE_CONNECTING",
            Self::Reconnecting => "WIFI_STATE_RECONNECTING",
            Self::FailedToConnect => "WIFI_STATE_FAILED_TO_CONNECT",
            Self::Disconnecting => "WIFI_STATE_DISCONNECTING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WIFI_STATE_DISCONNECTED" => Some(Self::Disconnected),
            "WIFI_STATE_CONNECTED" => Some(Self::Connected),
            "WIFI_STATE_CONNECTING" => Some(Self::Connecting),
            "WIFI_STATE_RECONNECTING" => Some(Self::Reconnecting),
            "WIFI_STATE_FAILED_TO_CONNECT" => Some(Self::FailedToConnect),
            "WIFI_STATE_DISCONNECTING" => Some(Self::Disconnecting),
            _ => None,
        }
    }
}
///
/// Excact copy of ESP_IDF wifi_err_reason_t (except for the first one)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WifiFailedReason {
    /// legacy compatibility - DO NOT USE
    WifiReasonDoNotUse = 0,
    WifiReasonUnspecified = 1,
    WifiReasonAuthExpire = 2,
    WifiReasonAuthLeave = 3,
    WifiReasonAssocExpire = 4,
    WifiReasonAssocToomany = 5,
    WifiReasonNotAuthed = 6,
    WifiReasonNotAssoced = 7,
    WifiReasonAssocLeave = 8,
    WifiReasonAssocNotAuthed = 9,
    WifiReasonDisassocPwrcapBad = 10,
    WifiReasonDisassocSupchanBad = 11,
    WifiReasonBssTransitionDisassoc = 12,
    WifiReasonIeInvalid = 13,
    WifiReasonMicFailure = 14,
    WifiReason4wayHandshakeTimeout = 15,
    WifiReasonGroupKeyUpdateTimeout = 16,
    WifiReasonIeIn4wayDiffers = 17,
    WifiReasonGroupCipherInvalid = 18,
    WifiReasonPairwiseCipherInvalid = 19,
    WifiReasonAkmpInvalid = 20,
    WifiReasonUnsuppRsnIeVersion = 21,
    WifiReasonInvalidRsnIeCap = 22,
    WifiReason8021xAuthFailed = 23,
    WifiReasonCipherSuiteRejected = 24,
    WifiReasonTdlsPeerUnreachable = 25,
    WifiReasonTdlsUnspecified = 26,
    WifiReasonSspRequestedDisassoc = 27,
    WifiReasonNoSspRoamingAgreement = 28,
    WifiReasonBadCipherOrAkm = 29,
    WifiReasonNotAuthorizedThisLocation = 30,
    WifiReasonServiceChangePercludesTs = 31,
    WifiReasonUnspecifiedQos = 32,
    WifiReasonNotEnoughBandwidth = 33,
    WifiReasonMissingAcks = 34,
    WifiReasonExceededTxop = 35,
    WifiReasonStaLeaving = 36,
    WifiReasonEndBa = 37,
    WifiReasonUnknownBa = 38,
    WifiReasonTimeout = 39,
    WifiReasonPeerInitiated = 46,
    WifiReasonApInitiated = 47,
    WifiReasonInvalidFtActionFrameCount = 48,
    WifiReasonInvalidPmkid = 49,
    WifiReasonInvalidMde = 50,
    WifiReasonInvalidFte = 51,
    WifiReasonTransmissionLinkEstablishFailed = 67,
    WifiReasonAlterativeChannelOccupied = 68,
    WifiReasonBeaconTimeout = 200,
    WifiReasonNoApFound = 201,
    WifiReasonAuthFail = 202,
    WifiReasonAssocFail = 203,
    WifiReasonHandshakeTimeout = 204,
    WifiReasonConnectionFail = 205,
    WifiReasonApTsfReset = 206,
    WifiReasonRoaming = 207,
    WifiReasonAssocComebackTimeTooLong = 208,
    WifiReasonSaQueryTimeout = 209,
}
impl WifiFailedReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::WifiReasonDoNotUse => "WIFI_REASON_DO_NOT_USE",
            Self::WifiReasonUnspecified => "WIFI_REASON_UNSPECIFIED",
            Self::WifiReasonAuthExpire => "WIFI_REASON_AUTH_EXPIRE",
            Self::WifiReasonAuthLeave => "WIFI_REASON_AUTH_LEAVE",
            Self::WifiReasonAssocExpire => "WIFI_REASON_ASSOC_EXPIRE",
            Self::WifiReasonAssocToomany => "WIFI_REASON_ASSOC_TOOMANY",
            Self::WifiReasonNotAuthed => "WIFI_REASON_NOT_AUTHED",
            Self::WifiReasonNotAssoced => "WIFI_REASON_NOT_ASSOCED",
            Self::WifiReasonAssocLeave => "WIFI_REASON_ASSOC_LEAVE",
            Self::WifiReasonAssocNotAuthed => "WIFI_REASON_ASSOC_NOT_AUTHED",
            Self::WifiReasonDisassocPwrcapBad => "WIFI_REASON_DISASSOC_PWRCAP_BAD",
            Self::WifiReasonDisassocSupchanBad => "WIFI_REASON_DISASSOC_SUPCHAN_BAD",
            Self::WifiReasonBssTransitionDisassoc => {
                "WIFI_REASON_BSS_TRANSITION_DISASSOC"
            }
            Self::WifiReasonIeInvalid => "WIFI_REASON_IE_INVALID",
            Self::WifiReasonMicFailure => "WIFI_REASON_MIC_FAILURE",
            Self::WifiReason4wayHandshakeTimeout => "WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT",
            Self::WifiReasonGroupKeyUpdateTimeout => {
                "WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT"
            }
            Self::WifiReasonIeIn4wayDiffers => "WIFI_REASON_IE_IN_4WAY_DIFFERS",
            Self::WifiReasonGroupCipherInvalid => "WIFI_REASON_GROUP_CIPHER_INVALID",
            Self::WifiReasonPairwiseCipherInvalid => {
                "WIFI_REASON_PAIRWISE_CIPHER_INVALID"
            }
            Self::WifiReasonAkmpInvalid => "WIFI_REASON_AKMP_INVALID",
            Self::WifiReasonUnsuppRsnIeVersion => "WIFI_REASON_UNSUPP_RSN_IE_VERSION",
            Self::WifiReasonInvalidRsnIeCap => "WIFI_REASON_INVALID_RSN_IE_CAP",
            Self::WifiReason8021xAuthFailed => "WIFI_REASON_802_1X_AUTH_FAILED",
            Self::WifiReasonCipherSuiteRejected => "WIFI_REASON_CIPHER_SUITE_REJECTED",
            Self::WifiReasonTdlsPeerUnreachable => "WIFI_REASON_TDLS_PEER_UNREACHABLE",
            Self::WifiReasonTdlsUnspecified => "WIFI_REASON_TDLS_UNSPECIFIED",
            Self::WifiReasonSspRequestedDisassoc => "WIFI_REASON_SSP_REQUESTED_DISASSOC",
            Self::WifiReasonNoSspRoamingAgreement => {
                "WIFI_REASON_NO_SSP_ROAMING_AGREEMENT"
            }
            Self::WifiReasonBadCipherOrAkm => "WIFI_REASON_BAD_CIPHER_OR_AKM",
            Self::WifiReasonNotAuthorizedThisLocation => {
                "WIFI_REASON_NOT_AUTHORIZED_THIS_LOCATION"
            }
            Self::WifiReasonServiceChangePercludesTs => {
                "WIFI_REASON_SERVICE_CHANGE_PERCLUDES_TS"
            }
            Self::WifiReasonUnspecifiedQos => "WIFI_REASON_UNSPECIFIED_QOS",
            Self::WifiReasonNotEnoughBandwidth => "WIFI_REASON_NOT_ENOUGH_BANDWIDTH",
            Self::WifiReasonMissingAcks => "WIFI_REASON_MISSING_ACKS",
            Self::WifiReasonExceededTxop => "WIFI_REASON_EXCEEDED_TXOP",
            Self::WifiReasonStaLeaving => "WIFI_REASON_STA_LEAVING",
            Self::WifiReasonEndBa => "WIFI_REASON_END_BA",
            Self::WifiReasonUnknownBa => "WIFI_REASON_UNKNOWN_BA",
            Self::WifiReasonTimeout => "WIFI_REASON_TIMEOUT",
            Self::WifiReasonPeerInitiated => "WIFI_REASON_PEER_INITIATED",
            Self::WifiReasonApInitiated => "WIFI_REASON_AP_INITIATED",
            Self::WifiReasonInvalidFtActionFrameCount => {
                "WIFI_REASON_INVALID_FT_ACTION_FRAME_COUNT"
            }
            Self::WifiReasonInvalidPmkid => "WIFI_REASON_INVALID_PMKID",
            Self::WifiReasonInvalidMde => "WIFI_REASON_INVALID_MDE",
            Self::WifiReasonInvalidFte => "WIFI_REASON_INVALID_FTE",
            Self::WifiReasonTransmissionLinkEstablishFailed => {
                "WIFI_REASON_TRANSMISSION_LINK_ESTABLISH_FAILED"
            }
            Self::WifiReasonAlterativeChannelOccupied => {
                "WIFI_REASON_ALTERATIVE_CHANNEL_OCCUPIED"
            }
            Self::WifiReasonBeaconTimeout => "WIFI_REASON_BEACON_TIMEOUT",
            Self::WifiReasonNoApFound => "WIFI_REASON_NO_AP_FOUND",
            Self::WifiReasonAuthFail => "WIFI_REASON_AUTH_FAIL",
            Self::WifiReasonAssocFail => "WIFI_REASON_ASSOC_FAIL",
            Self::WifiReasonHandshakeTimeout => "WIFI_REASON_HANDSHAKE_TIMEOUT",
            Self::WifiReasonConnectionFail => "WIFI_REASON_CONNECTION_FAIL",
            Self::WifiReasonApTsfReset => "WIFI_REASON_AP_TSF_RESET",
            Self::WifiReasonRoaming => "WIFI_REASON_ROAMING",
            Self::WifiReasonAssocComebackTimeTooLong => {
                "WIFI_REASON_ASSOC_COMEBACK_TIME_TOO_LONG"
            }
            Self::WifiReasonSaQueryTimeout => "WIFI_REASON_SA_QUERY_TIMEOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WIFI_REASON_DO_NOT_USE" => Some(Self::WifiReasonDoNotUse),
            "WIFI_REASON_UNSPECIFIED" => Some(Self::WifiReasonUnspecified),
            "WIFI_REASON_AUTH_EXPIRE" => Some(Self::WifiReasonAuthExpire),
            "WIFI_REASON_AUTH_LEAVE" => Some(Self::WifiReasonAuthLeave),
            "WIFI_REASON_ASSOC_EXPIRE" => Some(Self::WifiReasonAssocExpire),
            "WIFI_REASON_ASSOC_TOOMANY" => Some(Self::WifiReasonAssocToomany),
            "WIFI_REASON_NOT_AUTHED" => Some(Self::WifiReasonNotAuthed),
            "WIFI_REASON_NOT_ASSOCED" => Some(Self::WifiReasonNotAssoced),
            "WIFI_REASON_ASSOC_LEAVE" => Some(Self::WifiReasonAssocLeave),
            "WIFI_REASON_ASSOC_NOT_AUTHED" => Some(Self::WifiReasonAssocNotAuthed),
            "WIFI_REASON_DISASSOC_PWRCAP_BAD" => Some(Self::WifiReasonDisassocPwrcapBad),
            "WIFI_REASON_DISASSOC_SUPCHAN_BAD" => {
                Some(Self::WifiReasonDisassocSupchanBad)
            }
            "WIFI_REASON_BSS_TRANSITION_DISASSOC" => {
                Some(Self::WifiReasonBssTransitionDisassoc)
            }
            "WIFI_REASON_IE_INVALID" => Some(Self::WifiReasonIeInvalid),
            "WIFI_REASON_MIC_FAILURE" => Some(Self::WifiReasonMicFailure),
            "WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT" => {
                Some(Self::WifiReason4wayHandshakeTimeout)
            }
            "WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT" => {
                Some(Self::WifiReasonGroupKeyUpdateTimeout)
            }
            "WIFI_REASON_IE_IN_4WAY_DIFFERS" => Some(Self::WifiReasonIeIn4wayDiffers),
            "WIFI_REASON_GROUP_CIPHER_INVALID" => {
                Some(Self::WifiReasonGroupCipherInvalid)
            }
            "WIFI_REASON_PAIRWISE_CIPHER_INVALID" => {
                Some(Self::WifiReasonPairwiseCipherInvalid)
            }
            "WIFI_REASON_AKMP_INVALID" => Some(Self::WifiReasonAkmpInvalid),
            "WIFI_REASON_UNSUPP_RSN_IE_VERSION" => {
                Some(Self::WifiReasonUnsuppRsnIeVersion)
            }
            "WIFI_REASON_INVALID_RSN_IE_CAP" => Some(Self::WifiReasonInvalidRsnIeCap),
            "WIFI_REASON_802_1X_AUTH_FAILED" => Some(Self::WifiReason8021xAuthFailed),
            "WIFI_REASON_CIPHER_SUITE_REJECTED" => {
                Some(Self::WifiReasonCipherSuiteRejected)
            }
            "WIFI_REASON_TDLS_PEER_UNREACHABLE" => {
                Some(Self::WifiReasonTdlsPeerUnreachable)
            }
            "WIFI_REASON_TDLS_UNSPECIFIED" => Some(Self::WifiReasonTdlsUnspecified),
            "WIFI_REASON_SSP_REQUESTED_DISASSOC" => {
                Some(Self::WifiReasonSspRequestedDisassoc)
            }
            "WIFI_REASON_NO_SSP_ROAMING_AGREEMENT" => {
                Some(Self::WifiReasonNoSspRoamingAgreement)
            }
            "WIFI_REASON_BAD_CIPHER_OR_AKM" => Some(Self::WifiReasonBadCipherOrAkm),
            "WIFI_REASON_NOT_AUTHORIZED_THIS_LOCATION" => {
                Some(Self::WifiReasonNotAuthorizedThisLocation)
            }
            "WIFI_REASON_SERVICE_CHANGE_PERCLUDES_TS" => {
                Some(Self::WifiReasonServiceChangePercludesTs)
            }
            "WIFI_REASON_UNSPECIFIED_QOS" => Some(Self::WifiReasonUnspecifiedQos),
            "WIFI_REASON_NOT_ENOUGH_BANDWIDTH" => {
                Some(Self::WifiReasonNotEnoughBandwidth)
            }
            "WIFI_REASON_MISSING_ACKS" => Some(Self::WifiReasonMissingAcks),
            "WIFI_REASON_EXCEEDED_TXOP" => Some(Self::WifiReasonExceededTxop),
            "WIFI_REASON_STA_LEAVING" => Some(Self::WifiReasonStaLeaving),
            "WIFI_REASON_END_BA" => Some(Self::WifiReasonEndBa),
            "WIFI_REASON_UNKNOWN_BA" => Some(Self::WifiReasonUnknownBa),
            "WIFI_REASON_TIMEOUT" => Some(Self::WifiReasonTimeout),
            "WIFI_REASON_PEER_INITIATED" => Some(Self::WifiReasonPeerInitiated),
            "WIFI_REASON_AP_INITIATED" => Some(Self::WifiReasonApInitiated),
            "WIFI_REASON_INVALID_FT_ACTION_FRAME_COUNT" => {
                Some(Self::WifiReasonInvalidFtActionFrameCount)
            }
            "WIFI_REASON_INVALID_PMKID" => Some(Self::WifiReasonInvalidPmkid),
            "WIFI_REASON_INVALID_MDE" => Some(Self::WifiReasonInvalidMde),
            "WIFI_REASON_INVALID_FTE" => Some(Self::WifiReasonInvalidFte),
            "WIFI_REASON_TRANSMISSION_LINK_ESTABLISH_FAILED" => {
                Some(Self::WifiReasonTransmissionLinkEstablishFailed)
            }
            "WIFI_REASON_ALTERATIVE_CHANNEL_OCCUPIED" => {
                Some(Self::WifiReasonAlterativeChannelOccupied)
            }
            "WIFI_REASON_BEACON_TIMEOUT" => Some(Self::WifiReasonBeaconTimeout),
            "WIFI_REASON_NO_AP_FOUND" => Some(Self::WifiReasonNoApFound),
            "WIFI_REASON_AUTH_FAIL" => Some(Self::WifiReasonAuthFail),
            "WIFI_REASON_ASSOC_FAIL" => Some(Self::WifiReasonAssocFail),
            "WIFI_REASON_HANDSHAKE_TIMEOUT" => Some(Self::WifiReasonHandshakeTimeout),
            "WIFI_REASON_CONNECTION_FAIL" => Some(Self::WifiReasonConnectionFail),
            "WIFI_REASON_AP_TSF_RESET" => Some(Self::WifiReasonApTsfReset),
            "WIFI_REASON_ROAMING" => Some(Self::WifiReasonRoaming),
            "WIFI_REASON_ASSOC_COMEBACK_TIME_TOO_LONG" => {
                Some(Self::WifiReasonAssocComebackTimeTooLong)
            }
            "WIFI_REASON_SA_QUERY_TIMEOUT" => Some(Self::WifiReasonSaQueryTimeout),
            _ => None,
        }
    }
}
///
/// Must match typedef enum hdyConfigConnection_t
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConnectionMode {
    NotSet = 0,
    Wifi = 1,
    Ble = 2,
    /// NB! Extra latency when using this mode
    WifiAndBle = 3,
    Offline = 4,
    /// Only BLE. No legacy BLE+wifi mode
    LegacyBle = 5,
    /// (NOT IN USE!) Connects to factory wifi and server
    Factory = 6,
    /// Switch to Audio FW -> Reverts on next reboot
    Audio = 7,
}
impl ConnectionMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NotSet => "CONNECTION_MODE_NOT_SET",
            Self::Wifi => "CONNECTION_MODE_WIFI",
            Self::Ble => "CONNECTION_MODE_BLE",
            Self::WifiAndBle => "CONNECTION_MODE_WIFI_AND_BLE",
            Self::Offline => "CONNECTION_MODE_OFFLINE",
            Self::LegacyBle => "CONNECTION_MODE_LEGACY_BLE",
            Self::Factory => "CONNECTION_MODE_FACTORY",
            Self::Audio => "CONNECTION_MODE_AUDIO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONNECTION_MODE_NOT_SET" => Some(Self::NotSet),
            "CONNECTION_MODE_WIFI" => Some(Self::Wifi),
            "CONNECTION_MODE_BLE" => Some(Self::Ble),
            "CONNECTION_MODE_WIFI_AND_BLE" => Some(Self::WifiAndBle),
            "CONNECTION_MODE_OFFLINE" => Some(Self::Offline),
            "CONNECTION_MODE_LEGACY_BLE" => Some(Self::LegacyBle),
            "CONNECTION_MODE_FACTORY" => Some(Self::Factory),
            "CONNECTION_MODE_AUDIO" => Some(Self::Audio),
            _ => None,
        }
    }
}
///
/// Must match hdy_socket_server_env_t
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServerEnvironment {
    SocketServerEnvProduction = 0,
    SocketServerEnvStaging = 1,
    SocketServerEnvDevelopment = 2,
}
impl ServerEnvironment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SocketServerEnvProduction => "SOCKET_SERVER_ENV_PRODUCTION",
            Self::SocketServerEnvStaging => "SOCKET_SERVER_ENV_STAGING",
            Self::SocketServerEnvDevelopment => "SOCKET_SERVER_ENV_DEVELOPMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SOCKET_SERVER_ENV_PRODUCTION" => Some(Self::SocketServerEnvProduction),
            "SOCKET_SERVER_ENV_STAGING" => Some(Self::SocketServerEnvStaging),
            "SOCKET_SERVER_ENV_DEVELOPMENT" => Some(Self::SocketServerEnvDevelopment),
            _ => None,
        }
    }
}
///
/// Must match hdyBleConnectionStatus_t
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BleState {
    NotInitialized = 0,
    Initializing = 1,
    Advertising = 2,
    Connected = 3,
}
impl BleState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NotInitialized => "BLE_STATE_NOT_INITIALIZED",
            Self::Initializing => "BLE_STATE_INITIALIZING",
            Self::Advertising => "BLE_STATE_ADVERTISING",
            Self::Connected => "BLE_STATE_CONNECTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BLE_STATE_NOT_INITIALIZED" => Some(Self::NotInitialized),
            "BLE_STATE_INITIALIZING" => Some(Self::Initializing),
            "BLE_STATE_ADVERTISING" => Some(Self::Advertising),
            "BLE_STATE_CONNECTED" => Some(Self::Connected),
            _ => None,
        }
    }
}
/// There is no need to set the transportation. This is handled in the FW.
/// /////////////////////// Div constants /////////////////////////
/// Added in FW4.0.19
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BatteryDriver {
    NotSet = 0,
    /// Oh
    Oh = 1,
    /// Handy 2
    H2 = 2,
}
impl BatteryDriver {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NotSet => "BATTERY_DRIVER_NOT_SET",
            Self::Oh => "BATTERY_DRIVER_OH",
            Self::H2 => "BATTERY_DRIVER_H2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BATTERY_DRIVER_NOT_SET" => Some(Self::NotSet),
            "BATTERY_DRIVER_OH" => Some(Self::Oh),
            "BATTERY_DRIVER_H2" => Some(Self::H2),
            _ => None,
        }
    }
}
/// The 3 different potential Idle timeout states
/// Added in FW4.0.19
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IdleTimeoutState {
    /// Idle timeout warning - will go to sleep in 60 seconds if no interaction
    Warning = 0,
    /// Idle timeout cancelled - will not go to sleep
    Cancelled = 1,
    /// Idle timeout sleeping - device is now sleeping
    Sleeping = 2,
}
impl IdleTimeoutState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Warning => "IDLE_TIMEOUT_STATE_WARNING",
            Self::Cancelled => "IDLE_TIMEOUT_STATE_CANCELLED",
            Self::Sleeping => "IDLE_TIMEOUT_STATE_SLEEPING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IDLE_TIMEOUT_STATE_WARNING" => Some(Self::Warning),
            "IDLE_TIMEOUT_STATE_CANCELLED" => Some(Self::Cancelled),
            "IDLE_TIMEOUT_STATE_SLEEPING" => Some(Self::Sleeping),
            _ => None,
        }
    }
}
/// Used for settings changed notifications
/// Added in FW4.0.19
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SettingType {
    SettingsNotSet = 0,
    SettingsBase = 1,
    SettingsSlider = 2,
    SettingsLra = 3,
    SettingsErm = 4,
    SettingsBattery = 5,
}
impl SettingType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SettingsNotSet => "SETTINGS_NOT_SET",
            Self::SettingsBase => "SETTINGS_BASE",
            Self::SettingsSlider => "SETTINGS_SLIDER",
            Self::SettingsLra => "SETTINGS_LRA",
            Self::SettingsErm => "SETTINGS_ERM",
            Self::SettingsBattery => "SETTINGS_BATTERY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SETTINGS_NOT_SET" => Some(Self::SettingsNotSet),
            "SETTINGS_BASE" => Some(Self::SettingsBase),
            "SETTINGS_SLIDER" => Some(Self::SettingsSlider),
            "SETTINGS_LRA" => Some(Self::SettingsLra),
            "SETTINGS_ERM" => Some(Self::SettingsErm),
            "SETTINGS_BATTERY" => Some(Self::SettingsBattery),
            _ => None,
        }
    }
}
/// ******* NOTIFICATIONS *********/
/// 601 - wifi
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationWifiStatusChanged {
    #[prost(enumeration = "WifiState", tag = "2")]
    pub state: i32,
    #[prost(bool, tag = "4")]
    pub socket_connected: bool,
    #[prost(uint32, tag = "5")]
    pub socket_session_id: u32,
}
/// 602 - BLE
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationBleStatusChanged {
    #[prost(enumeration = "BleState", tag = "1")]
    pub state: i32,
}
/// 603 - OTA complete - Sent when the OTA is completed successfully - It is now safe to reboot
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationOtaComplete {}
/// 700
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationModeChanged {
    #[prost(enumeration = "Mode", tag = "1")]
    pub mode: i32,
    #[prost(uint32, tag = "2")]
    pub mode_session_id: u32,
}
/// 701
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotificationStrokeChanged {
    #[prost(float, tag = "1")]
    pub min: f32,
    #[prost(float, tag = "2")]
    pub max: f32,
    #[prost(float, tag = "3")]
    pub min_absolute: f32,
    #[prost(float, tag = "4")]
    pub max_absolute: f32,
}
/// 703
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationButtonEvent {
    #[prost(enumeration = "Button", tag = "1")]
    pub button: i32,
    #[prost(enumeration = "ButtonEvent", tag = "2")]
    pub event: i32,
}
/// 705
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotificationBatteryChanged {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<BatteryState>,
}
/// 720
///
/// TODO: Make this push a hamp state message
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotificationHampChanged {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HampState>,
}
/// 740
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationHdspChanged {
    #[prost(enumeration = "HdspPlayState", tag = "1")]
    pub state: i32,
}
/// 860 - tail_point_stream_index_threashold reached
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotificationHspThresholdReached {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotificationHspStateChanged {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// Limited to 2 messages per second (0.5s interval) -> Prevents spamming on short scripts
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotificationHspLooping {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotificationHspStarving {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// When pauseOnEmptyBuffer == true and we reached starving state. When adding more data to the buffer, we will RESUME the HSP and send this notification
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotificationHspResumedOnNonStarving {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// When pauseOnEmptyBuffer == true and we reached starving state we send this notification after PAUSE HSP
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotificationHspPausedOnStarving {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 900
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotificationHvpChanged {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HvpState>,
}
/// 920
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationHrppChanged {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HrppState>,
}
/// Handy error notifications starts at 800
/// 800
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationTempHigh {}
/// 801
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationTempOk {}
/// 802
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationSliderBlocked {}
/// 803
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationSliderUnblocked {}
/// Sent when a message is discarded due to low memory (we do not have memory to parse the message, so the only thing we can do to identify the message is to check the size)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationLowMemoryError {
    #[prost(uint32, tag = "1")]
    pub available_heap: u32,
    #[prost(uint32, tag = "2")]
    pub largest_free_block: u32,
    #[prost(uint32, tag = "3")]
    pub discarded_msg_size: u32,
}
/// Triggers when we ahve very little memory left. Little is TBD
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationLowMemoryWarning {
    #[prost(uint32, tag = "1")]
    pub available_heap: u32,
    #[prost(uint32, tag = "2")]
    pub largest_free_block: u32,
}
/// Generic error message
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationError {
    #[prost(int32, tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Triggered when a wifi scan is completed
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationWifiScanComplete {
    #[prost(uint32, tag = "1")]
    pub nr_of_networks: u32,
}
/// Triggers when the motor has been inactive for a while (configurable) - Battery devices will shut down and non-battery devices will disconnect WiFi
/// Will go to sleep after 60 seconds after this notification
/// Added in FW4.0.19
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationIdleTimeout {
    #[prost(enumeration = "IdleTimeoutState", tag = "1")]
    pub state: i32,
    /// \[ms\] The time the device has been idle
    #[prost(uint32, tag = "2")]
    pub idle_time: u32,
    /// \[ms\] The time until the device will go to sleep (hardcoded to 60 seconds)
    #[prost(uint32, tag = "3")]
    pub warning_time: u32,
}
/// Give all the connected clients a notification when a setting is changed - Useful for the server to know that a setting has changed in the onboarding app
/// Added in FW4.0.19
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotificationSettingsChanged {
    /// The type of setting that has changed
    #[prost(enumeration = "SettingType", tag = "1")]
    pub r#type: i32,
}
/// 606
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestConnectionKeyGet {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseConnectionKeyGet {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
/// /////////////////////// WIFI configuration 620-639 /////////////////////////
/// 620 Port for wifi_prov_config_get_data_t - Get the current state of the wifi connection
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestWifiStatusGet {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseWifiStatusGet {
    /// Info on the current AP connection (Blank if not connected)
    #[prost(message, optional, tag = "1")]
    pub ap_info: ::core::option::Option<ApInfo>,
    #[prost(enumeration = "WifiState", tag = "2")]
    pub state: i32,
    #[prost(enumeration = "WifiFailedReason", tag = "3")]
    pub failed_reason: i32,
    #[prost(bool, tag = "4")]
    pub socket_connected: bool,
    /// Of the last configured AP stored - NB! Can be different from the connected AP SSID
    #[prost(string, tag = "5")]
    pub ssid: ::prost::alloc::string::String,
}
/// 621
/// Port for wifi_prov_config_set_data_t - Set the wifi configuration
/// If connected to WiFi, this call will disconnect the device from the current AP. It will not connect to the new AP.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestWifiSet {
    #[prost(string, tag = "1")]
    pub ssid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    /// store in NVS (currently not used -> Alwaysed stored)
    #[prost(bool, tag = "3")]
    pub save: bool,
}
/// port for _hdy_pc_prov_config_config_apply is not needed since we can set the WiFi by OnlineModeSet
/// 623 Port for _hdy_pc_prov_scan_start+result - Start wifi scan. Rembember to stop the scan when done! Returns OK if scan has started ok. Returns a scan complete notification when the scan is done.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestWifiScanStart {
    /// \[default:false\] If true, the system will wait for the scan to finish before sending the Blank OK. NB! This is one of the few blocking RPC calls!
    #[prost(bool, tag = "1")]
    pub blocking: bool,
    /// \[default:false\] if false or not set -> active scan
    #[prost(bool, tag = "2")]
    pub passive: bool,
    /// \[default:all channels==0\]uint8_t scan the specific channel. if not set -> all channels
    #[prost(uint32, tag = "3")]
    pub channel: u32,
    /// \[default:false\]if true -> show hidden networks
    #[prost(bool, tag = "4")]
    pub show_hidden: bool,
    /// \[default:regular scantime values\] ms. Only used if passive is true. If not set, the default value is used. passive scan time per channel, units: millisecond, values above 1500ms may cause station to disconnect from AP and are not recommended.
    #[prost(uint32, tag = "5")]
    pub passive_scan_time: u32,
    /// \[default:regular scantime values\] ms. Only used if passive is false. If not set, the default value is used.
    #[prost(uint32, tag = "6")]
    pub active_scan_time_min: u32,
    /// \[default:regular scantime values\] ms. Only used if passive is false. If not set, the default value is used. values above 1500ms may cause station to disconnect from AP and are not recommended.
    #[prost(uint32, tag = "7")]
    pub active_scan_time_max: u32,
}
/// 624
/// Due to BLE limitations, the results are sent in chunks
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestWifiScanResultsGet {
    /// Max 10 (NB! can be changed in the future)
    #[prost(uint32, tag = "1")]
    pub max_results: u32,
    /// Offset index for the results
    #[prost(uint32, tag = "2")]
    pub offset_index: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseWifiScanResultsGet {
    /// Max 10 (can be changed). Will be empty if no results or failed
    #[prost(message, repeated, tag = "1")]
    pub ap_info: ::prost::alloc::vec::Vec<ApInfo>,
    /// Total number of results
    #[prost(uint32, tag = "2")]
    pub total_results: u32,
}
/// 625
/// Clean up the scan results and free memory on the device
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestWifiScanStop {}
/// 700
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestModeGet {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseModeGet {
    #[prost(enumeration = "Mode", tag = "1")]
    pub mode: i32,
    #[prost(uint32, tag = "2")]
    pub mode_session_id: u32,
}
/// 701
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestModeSet {
    #[prost(enumeration = "Mode", tag = "1")]
    pub mode: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseModeSet {
    #[prost(enumeration = "Mode", tag = "1")]
    pub mode: i32,
    #[prost(uint32, tag = "2")]
    pub mode_session_id: u32,
}
///
/// Reboots the device.
/// The connection mode at start can be overriden by the connection_mode parameter.
/// NB! This override will only be used once. After the first boot, the connection mode will be set to the value in settings.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestReboot {
    /// how the machine will connect after boot
    #[prost(enumeration = "ConnectionMode", tag = "3")]
    pub connection_mode: i32,
}
/// 708
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestButtonPress {
    #[prost(uint32, tag = "1")]
    pub button: u32,
    #[prost(enumeration = "ButtonEvent", tag = "2")]
    pub event: i32,
}
/// 709
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestClockOffsetSet {
    /// Clock offset in ms (difference between server (UNIX) and machine time (ms since boot)))
    #[prost(sint64, tag = "1")]
    pub clock_offset: i64,
    /// send 0 (or do not send) to not set. Just storing the RTD for the machine to be used in future GET requests. Set it to the RTD used in the clockOffset calculation.
    #[prost(int32, tag = "2")]
    pub rtd: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseClockOffsetSet {
    /// Machine time (ms since boot)
    #[prost(uint32, tag = "1")]
    pub time: u32,
    /// Clock offset in ms (difference between server (UNIX) and machine time (ms since boot)))
    #[prost(sint64, tag = "2")]
    pub clock_offset: i64,
    /// round trip delay in ms for the machine (set by client in RequestClockOffsetSet) NB! not calaculated by the machine!
    #[prost(int32, tag = "3")]
    pub rtd: i32,
}
/// 710
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestBatteryGet {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseBatteryGet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<BatteryState>,
}
/// 712
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestClockOffsetGet {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseClockOffsetGet {
    /// Machine time (ms since boot)
    #[prost(uint32, tag = "1")]
    pub time: u32,
    /// Clock offset in ms (difference between server (UNIX) and machine time (ms since boot)))
    #[prost(sint64, tag = "2")]
    pub clock_offset: i64,
    /// round trip delay in ms for the machine (set by client in RequestClockOffsetSet) NB! not calaculated by the machine!
    #[prost(int32, tag = "3")]
    pub rtd: i32,
}
/// 713
/// Get the system capabilities
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestCapabilitiesGet {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseCapabilitiesGet {
    /// If the device is vulva oriented. If not, then it pen** oriented or both (cannot use the p word, since copilot will block auto complete)
    #[prost(bool, tag = "1")]
    pub vulva_oriented: bool,
    /// If the device has battery
    #[prost(bool, tag = "2")]
    pub battery: bool,
    /// \[uint8\]nr of sliders
    #[prost(uint32, tag = "3")]
    pub slider: u32,
    /// \[uint8\]nr of LRAs on the system
    #[prost(uint32, tag = "4")]
    pub lra: u32,
    /// \[uint8\]nr of ERMs on the system
    #[prost(uint32, tag = "5")]
    pub erm: u32,
    /// If the device has external memory
    #[prost(bool, tag = "6")]
    pub external_memory: bool,
    /// If the device has a RGB LED installed
    #[prost(bool, tag = "7")]
    pub rgb_led_indicator: bool,
    /// If the device has a LED matrix installed
    #[prost(bool, tag = "8")]
    pub led_matrix: bool,
    /// \[uint8\]Nr of leds in X axis
    #[prost(uint32, tag = "9")]
    pub led_matrix_leds_x: u32,
    /// \[uint8\]Nr of leds in Y axis
    #[prost(uint32, tag = "10")]
    pub led_matrix_leds_y: u32,
    /// If the device has a RGB ring indicator
    #[prost(bool, tag = "11")]
    pub rgb_ring: bool,
    /// \[uint8\]Nr of leds in the RGB ring
    #[prost(uint32, tag = "12")]
    pub rgb_ring_leds: u32,
    /// Battery capacity in mAh
    #[prost(uint32, tag = "13")]
    pub battery_capacity: u32,
    /// Battery driver type - Added in FW4.0.19
    #[prost(enumeration = "BatteryDriver", tag = "14")]
    pub battery_driver: i32,
}
///
/// Get the session ids (Random Int) (mode, socket and boot)
/// - Added in FW4.0.11
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestSessionIdsGet {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseSessionIdsGet {
    /// (Random uint32) Changes each time the device boots
    #[prost(uint32, tag = "1")]
    pub boot_session_id: u32,
    /// Starts at 0 and inc on each DISCONNECT event. Each reconnect attempt will trigger a disconnect. NB! After a WiFi disconnect, the session id might get incremented by 2.
    #[prost(uint32, tag = "2")]
    pub socket_session_id: u32,
    /// Starts at 0 and inc on each mode change. NB! was random in FW4.0.11 and FW4.0.12
    #[prost(uint32, tag = "3")]
    pub mode_session_id: u32,
}
/// 715 - Added in FW4.0.13
/// Stop the device no matter the mode.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestStopCurrentMode {}
/// 716 - Added in FW4.0.13
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestConnectionModeSet {
    #[prost(enumeration = "ConnectionMode", tag = "1")]
    pub mode: i32,
}
/// 717 - Added in FW4.0.13
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestConnectionModeGet {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseConnectionModeGet {
    #[prost(enumeration = "ConnectionMode", tag = "1")]
    pub mode: i32,
}
/// /////////////////////// HAMP /////////////////////////
/// 720
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHampStart {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHampStart {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HampState>,
}
/// 721
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHampStop {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHampStop {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HampState>,
}
/// 723
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHampVelocitySet {
    /// Default is 0%
    #[prost(float, tag = "1")]
    pub velocity: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHampVelocitySet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HampState>,
}
/// 724
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHampStateGet {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHampStateGet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HampState>,
}
/// 725 - Added in FW4.0.15
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHampZoneSet {
    /// \[0-1\] Min value of the zone in %
    #[prost(float, tag = "1")]
    pub min: f32,
    /// \[0-1\] Max value of the zone in %
    #[prost(float, tag = "2")]
    pub max: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHampZoneSet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HampState>,
}
/// /////////////////////// HDSP /////////////////////////
/// NB! Absolute values are capped within limits.
/// 740
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHdspXaVaSet {
    #[prost(float, tag = "1")]
    pub xa: f32,
    #[prost(float, tag = "2")]
    pub va: f32,
    #[prost(bool, tag = "3")]
    pub stop_on_target: bool,
}
/// 741
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHdspXpVaSet {
    #[prost(float, tag = "1")]
    pub xp: f32,
    #[prost(float, tag = "2")]
    pub va: f32,
    #[prost(bool, tag = "3")]
    pub stop_on_target: bool,
}
/// 742
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHdspXpVpSet {
    #[prost(float, tag = "1")]
    pub xp: f32,
    #[prost(float, tag = "2")]
    pub vp: f32,
    #[prost(bool, tag = "3")]
    pub stop_on_target: bool,
}
/// 743
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHdspXaTSet {
    #[prost(float, tag = "1")]
    pub xa: f32,
    #[prost(uint32, tag = "2")]
    pub t: u32,
    #[prost(bool, tag = "3")]
    pub stop_on_target: bool,
}
/// 744
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHdspXpTSet {
    #[prost(float, tag = "1")]
    pub xp: f32,
    #[prost(uint32, tag = "2")]
    pub t: u32,
    #[prost(bool, tag = "3")]
    pub stop_on_target: bool,
}
/// 745
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHdspXaVpSet {
    #[prost(float, tag = "1")]
    pub xa: f32,
    #[prost(float, tag = "2")]
    pub vp: f32,
    #[prost(bool, tag = "3")]
    pub stop_on_target: bool,
}
/// 746
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHdspStop {}
/// /////////////////////// Slider /////////////////////////
/// 840
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestSliderStrokeGet {}
/// TODO: Move to Slider state?
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseSliderStrokeGet {
    #[prost(float, tag = "1")]
    pub min: f32,
    #[prost(float, tag = "2")]
    pub max: f32,
    #[prost(float, tag = "3")]
    pub min_absolute: f32,
    #[prost(float, tag = "4")]
    pub max_absolute: f32,
}
/// 841
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestSliderStrokeSet {
    #[prost(float, tag = "1")]
    pub min: f32,
    #[prost(float, tag = "2")]
    pub max: f32,
}
/// Return to match the notification. If not the caller does not know the state of the absolute values
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseSliderStrokeSet {
    #[prost(float, tag = "1")]
    pub min: f32,
    #[prost(float, tag = "2")]
    pub max: f32,
    #[prost(float, tag = "3")]
    pub min_absolute: f32,
    #[prost(float, tag = "4")]
    pub max_absolute: f32,
}
/// 842
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestSliderStateGet {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseSliderStateGet {
    /// \[percentage\]
    #[prost(float, tag = "1")]
    pub position: f32,
    /// \[mm\]
    #[prost(float, tag = "2")]
    pub position_absolute: f32,
    /// \[Degrees C\]
    #[prost(float, tag = "3")]
    pub motor_temp: f32,
    /// \[mm/s\]
    #[prost(float, tag = "4")]
    pub speed_absolute: f32,
    /// true = forward, false = backward
    #[prost(bool, tag = "5")]
    pub dir: bool,
    /// hall patter signal \[0-2\]. In Handy H01, change results in 1/12 rotation
    #[prost(uint32, tag = "6")]
    pub motor_position: u32,
    /// 0-4095. ADC value of the motor temperature sensor - Added in FW4.0.16
    #[prost(uint32, tag = "7")]
    pub motor_temp_adc_value: u32,
}
/// 843 - Moves the slider to the absolute position and reset encoder
/// Added in FW4.0.15
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestSliderCalibrate {
    /// If true, the slider will move to the start position (END_BUFFER ~5mm) after calibration
    #[prost(bool, tag = "1")]
    pub go_to_start: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseSliderCalibrate {
    /// If the calibration was successful
    #[prost(bool, tag = "1")]
    pub success: bool,
}
/// /////////////////////// HSP /////////////////////////
/// 860
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHspSetup {
    /// \[Default 0\] a stream id to identify the stream.
    #[prost(uint32, tag = "1")]
    pub stream_id: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspSetup {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 861
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestHspAdd {
    #[prost(message, repeated, tag = "1")]
    pub points: ::prost::alloc::vec::Vec<Point>,
    /// clear the current points before adding the new ones.
    #[prost(bool, tag = "2")]
    pub flush: bool,
    /// \[Default points -1\] Absolute point of the last point added. Used for threshold notifications and to keep track of absoulute position for the client.
    #[prost(uint32, tag = "3")]
    pub tail_point_stream_index: u32,
    /// Added in FW4.0.13. If not 0, the device will send a notification when this point is played.
    #[prost(uint32, tag = "5")]
    pub tail_point_threshold: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspAdd {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 862
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHspFlush {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspFlush {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 863
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHspPlay {
    /// \[DEFAULT 0\] can be negative
    #[prost(int32, tag = "1")]
    pub start_time: i32,
    /// \[OPTIONAL\] Estimated server time on sending. Optional. If not set, there is no network latency adjustment.
    #[prost(uint64, tag = "2")]
    pub server_time: u64,
    /// \[DEFAULT 1\] playback rate (1 = normal speed), < 1 = slower, > 1 = faster. Must be positive.
    #[prost(float, tag = "3")]
    pub playback_rate: f32,
    /// \[DEFAULT false\]
    #[prost(bool, tag = "4")]
    pub r#loop: bool,
    /// \[Default false\] If true, the stream will pause when the buffer is empty. When data is added the stream will resume without time adjustments
    #[prost(bool, tag = "5")]
    pub pause_on_starving: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspPlay {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 864
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHspStop {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspStop {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 865
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHspPause {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspPause {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 866
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHspResume {
    /// \[DEFAULT false\] If false, then the current time will resume where it pause. If true, the stream will pick up  where it should be.
    #[prost(bool, tag = "1")]
    pub pick_up: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspResume {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 867
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHspStateGet {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspStateGet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 868
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHspCurrentTimeSet {
    #[prost(int32, tag = "1")]
    pub current_time: i32,
    /// Estimated server time on sending. Optional. If not set, there is no network latency adjustment.
    #[prost(uint64, tag = "2")]
    pub server_time: u64,
    /// \[DEFAULT 0.5\] [0-1] 1 will force current time. Lower values will drift into the actuall currentTime
    #[prost(float, tag = "3")]
    pub filter: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspCurrentTimeSet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 869
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHspThresholdSet {
    /// If not 0, the device will send a notification when this point is played.
    #[prost(uint32, tag = "1")]
    pub tail_point_threshold: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspThresholdSet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// 870 - Added in FW4.0.13
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHspPauseOnStarvingSet {
    /// If true, the stream will pause when the buffer is empty. When data is added the stream will resume without time adjustments
    #[prost(bool, tag = "1")]
    pub pause_on_starving: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHspPauseOnStarvingSet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HspState>,
}
/// /////////////////////// HMI 880->899 /////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestLedOverride {
    /// If true, the system will ignore the current mode and use the override color. Must be true for the override color to be used.
    #[prost(bool, tag = "1")]
    pub r#override: bool,
    /// \[0-255\] -> uint8 in FW
    #[prost(uint32, tag = "2")]
    pub r: u32,
    /// \[0-255\] -> uint8 in FW
    #[prost(uint32, tag = "3")]
    pub g: u32,
    /// \[0-255\] -> uint8 in FW
    #[prost(uint32, tag = "4")]
    pub b: u32,
    /// \[0-100\] -> uint8 in FW
    #[prost(uint32, tag = "5")]
    pub intensity: u32,
}
/// /////////////////////// HVP /////////////////////////
/// 900
/// NB will also trigger a start
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHvpSet {
    /// 0-1 (0-100%) For LRA, ERM and Sliders with vibration adapter (percent of valid output range)
    #[prost(float, tag = "1")]
    pub amplitude: f32,
    /// 0-10000 (Hz) For LRA only
    #[prost(uint32, tag = "2")]
    pub frequency: u32,
    /// (mm) Where on the slider should the vibration be. For slider with vibration adapter only.
    #[prost(float, tag = "3")]
    pub position: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHvpSet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HvpState>,
}
/// 901
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHvpStop {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHvpStop {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HvpState>,
}
/// 902
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHvpStart {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHvpStart {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HvpState>,
}
/// 903
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHvpStateGet {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseHvpStateGet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HvpState>,
}
/// /////////////////////// HRPP /////////////////////////
/// Added in FW4.0.14 - But some messages where altered in FW4.0.15. So, only compatible with FW4.0.15 and later
/// 920
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHrppStart {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseHrppStart {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HrppState>,
}
/// 921
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHrppStop {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseHrppStop {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HrppState>,
}
/// 922
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHrppAmplitudeSet {
    /// 0-1 (0-100%)
    #[prost(float, tag = "1")]
    pub amplitude: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseHrppAmplitudeSet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HrppState>,
}
/// 923
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestHrppPlaybackSpeedSet {
    /// Must be bigger than 0
    #[prost(float, tag = "1")]
    pub speed: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseHrppPlaybackSpeedSet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HrppState>,
}
/// 924
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHrppPatternSet {
    /// 0-MAX_PATTERN_NR
    #[prost(uint32, tag = "1")]
    pub pattern_nr: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseHrppPatternSet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HrppState>,
}
/// 925
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHrppStateGet {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseHrppStateGet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HrppState>,
}
/// 926
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestHrppPatternsGet {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseHrppPatternsGet {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<HrppState>,
    #[prost(message, repeated, tag = "2")]
    pub patterns: ::prost::alloc::vec::Vec<HrppPattern>,
}
///
/// Concepts
/// - All commands are sent as a request and a response
/// - All commands should give response "instantly" -> If there is a command that will take time to execute, the device should send an OK/error to the msg instantly, and then a notification when it is done.
/// - All commands should have a response
/// - Response can be blank
/// - All commands should have a unique ID for response
/// - All responses should have a result code
/// - All responses should match the request ID
/// - You can send a bundle of request in one requests message
/// - The responses will be sent back individually
/// - Some messages need to set a has_xxx flag to true for the FW to handle the corresponding value
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notification {
    /// Added in FW 4.0.14
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(
        oneof = "notification::Notification",
        tags = "600, 601, 602, 603, 700, 701, 703, 705, 706, 707, 720, 740, 860, 861, 862, 863, 864, 865, 900, 920, 1000, 1001, 1002, 1003, 1004, 1005, 2000"
    )]
    pub notification: ::core::option::Option<notification::Notification>,
}
/// Nested message and enum types in `Notification`.
pub mod notification {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Notification {
        /// BLE specific notifications starts with 600
        #[prost(message, tag = "600")]
        NotificationWifiScanComplete(super::NotificationWifiScanComplete),
        #[prost(message, tag = "601")]
        NotificationWifiStatusChanged(super::NotificationWifiStatusChanged),
        #[prost(message, tag = "602")]
        NotificationBleStatusChanged(super::NotificationBleStatusChanged),
        #[prost(message, tag = "603")]
        NotificationOtaComplete(super::NotificationOtaComplete),
        /// Handy Notifications starts with 700
        #[prost(message, tag = "700")]
        NotificationModeChanged(super::NotificationModeChanged),
        #[prost(message, tag = "701")]
        NotificationStrokeChanged(super::NotificationStrokeChanged),
        #[prost(message, tag = "703")]
        NotificationButtonEvent(super::NotificationButtonEvent),
        #[prost(message, tag = "705")]
        NotificationBatteryChanged(super::NotificationBatteryChanged),
        #[prost(message, tag = "706")]
        NotificationError(super::NotificationError),
        /// Added in FW4.0.19
        #[prost(message, tag = "707")]
        NotificationIdleTimeout(super::NotificationIdleTimeout),
        #[prost(message, tag = "720")]
        NotificationHampChanged(super::NotificationHampChanged),
        #[prost(message, tag = "740")]
        NotificationHdspChanged(super::NotificationHdspChanged),
        #[prost(message, tag = "860")]
        NotificationHspThresholdReached(super::NotificationHspThresholdReached),
        #[prost(message, tag = "861")]
        NotificationHspStateChanged(super::NotificationHspStateChanged),
        #[prost(message, tag = "862")]
        NotificationHspLooping(super::NotificationHspLooping),
        #[prost(message, tag = "863")]
        NotificationHspStarving(super::NotificationHspStarving),
        #[prost(message, tag = "864")]
        NotificationHspResumedOnNonStarving(super::NotificationHspResumedOnNonStarving),
        #[prost(message, tag = "865")]
        NotificationHspPausedOnStarving(super::NotificationHspPausedOnStarving),
        /// 900 - HVP
        #[prost(message, tag = "900")]
        NotificationHvpChanged(super::NotificationHvpChanged),
        /// HRPP - 920
        #[prost(message, tag = "920")]
        NotificationHrppChanged(super::NotificationHrppChanged),
        /// Handy error notifications starts with 1000
        #[prost(message, tag = "1000")]
        NotificationTempHigh(super::NotificationTempHigh),
        #[prost(message, tag = "1001")]
        NotificationTempOk(super::NotificationTempOk),
        #[prost(message, tag = "1002")]
        NotificationSliderBlocked(super::NotificationSliderBlocked),
        #[prost(message, tag = "1003")]
        NotificationSliderUnblocked(super::NotificationSliderUnblocked),
        #[prost(message, tag = "1004")]
        NotificationLowMemoryError(super::NotificationLowMemoryError),
        #[prost(message, tag = "1005")]
        NotificationLowMemoryWarning(super::NotificationLowMemoryWarning),
        /// Added in FW4.0.19
        #[prost(message, tag = "2000")]
        NotificationSettingsChanged(super::NotificationSettingsChanged),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Request {
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(
        oneof = "request::Params",
        tags = "606, 620, 621, 623, 624, 625, 700, 701, 707, 708, 709, 710, 712, 713, 714, 715, 716, 717, 720, 721, 723, 724, 725, 740, 741, 742, 743, 744, 745, 746, 840, 841, 842, 843, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 880, 900, 901, 902, 903, 920, 921, 922, 923, 924, 925, 926"
    )]
    pub params: ::core::option::Option<request::Params>,
}
/// Nested message and enum types in `Request`.
pub mod request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Params {
        #[prost(message, tag = "606")]
        RequestConnectionKeyGet(super::RequestConnectionKeyGet),
        #[prost(message, tag = "620")]
        RequestWifiStatusGet(super::RequestWifiStatusGet),
        #[prost(message, tag = "621")]
        RequestWifiSet(super::RequestWifiSet),
        #[prost(message, tag = "623")]
        RequestWifiScanStart(super::RequestWifiScanStart),
        #[prost(message, tag = "624")]
        RequestWifiScanResultsGet(super::RequestWifiScanResultsGet),
        #[prost(message, tag = "625")]
        RequestWifiScanStop(super::RequestWifiScanStop),
        /// client public requests starts at 700
        #[prost(message, tag = "700")]
        RequestModeGet(super::RequestModeGet),
        #[prost(message, tag = "701")]
        RequestModeSet(super::RequestModeSet),
        #[prost(message, tag = "707")]
        RequestReboot(super::RequestReboot),
        #[prost(message, tag = "708")]
        RequestButtonPress(super::RequestButtonPress),
        #[prost(message, tag = "709")]
        RequestClockOffsetSet(super::RequestClockOffsetSet),
        #[prost(message, tag = "710")]
        RequestBatteryGet(super::RequestBatteryGet),
        #[prost(message, tag = "712")]
        RequestClockOffsetGet(super::RequestClockOffsetGet),
        #[prost(message, tag = "713")]
        RequestCapabilitiesGet(super::RequestCapabilitiesGet),
        #[prost(message, tag = "714")]
        RequestSessionIdsGet(super::RequestSessionIdsGet),
        /// Added in FW4.0.13
        #[prost(message, tag = "715")]
        RequestStopCurrentMode(super::RequestStopCurrentMode),
        /// Added in FW4.0.13
        #[prost(message, tag = "716")]
        RequestConnectionModeSet(super::RequestConnectionModeSet),
        /// Added in FW4.0.13
        #[prost(message, tag = "717")]
        RequestConnectionModeGet(super::RequestConnectionModeGet),
        /// HAMP - 720
        #[prost(message, tag = "720")]
        RequestHampStart(super::RequestHampStart),
        #[prost(message, tag = "721")]
        RequestHampStop(super::RequestHampStop),
        #[prost(message, tag = "723")]
        RequestHampVelocitySet(super::RequestHampVelocitySet),
        #[prost(message, tag = "724")]
        RequestHampStateGet(super::RequestHampStateGet),
        /// Added in FW4.0.15
        #[prost(message, tag = "725")]
        RequestHampZoneSet(super::RequestHampZoneSet),
        /// HDSP - 740
        #[prost(message, tag = "740")]
        RequestHdspXaVaSet(super::RequestHdspXaVaSet),
        #[prost(message, tag = "741")]
        RequestHdspXpVaSet(super::RequestHdspXpVaSet),
        #[prost(message, tag = "742")]
        RequestHdspXpVpSet(super::RequestHdspXpVpSet),
        #[prost(message, tag = "743")]
        RequestHdspXaTSet(super::RequestHdspXaTSet),
        #[prost(message, tag = "744")]
        RequestHdspXpTSet(super::RequestHdspXpTSet),
        #[prost(message, tag = "745")]
        RequestHdspXaVpSet(super::RequestHdspXaVpSet),
        #[prost(message, tag = "746")]
        RequestHdspStop(super::RequestHdspStop),
        /// SLIDE - 840
        #[prost(message, tag = "840")]
        RequestSliderStrokeGet(super::RequestSliderStrokeGet),
        #[prost(message, tag = "841")]
        RequestSliderStrokeSet(super::RequestSliderStrokeSet),
        #[prost(message, tag = "842")]
        RequestSliderStateGet(super::RequestSliderStateGet),
        /// Added in FW4.0.15
        #[prost(message, tag = "843")]
        RequestSliderCalibrate(super::RequestSliderCalibrate),
        /// HSP - 860
        #[prost(message, tag = "860")]
        RequestHspSetup(super::RequestHspSetup),
        #[prost(message, tag = "861")]
        RequestHspAdd(super::RequestHspAdd),
        #[prost(message, tag = "862")]
        RequestHspFlush(super::RequestHspFlush),
        #[prost(message, tag = "863")]
        RequestHspPlay(super::RequestHspPlay),
        #[prost(message, tag = "864")]
        RequestHspStop(super::RequestHspStop),
        #[prost(message, tag = "865")]
        RequestHspPause(super::RequestHspPause),
        #[prost(message, tag = "866")]
        RequestHspResume(super::RequestHspResume),
        #[prost(message, tag = "867")]
        RequestHspStateGet(super::RequestHspStateGet),
        #[prost(message, tag = "868")]
        RequestHspCurrentTimeSet(super::RequestHspCurrentTimeSet),
        #[prost(message, tag = "869")]
        RequestHspThresholdSet(super::RequestHspThresholdSet),
        /// Added in FW4.0.13
        #[prost(message, tag = "870")]
        RequestHspPauseOnStarvingSet(super::RequestHspPauseOnStarvingSet),
        /// HMI (LED, screen and so on) - 880
        #[prost(message, tag = "880")]
        RequestLedOverride(super::RequestLedOverride),
        /// HVP (vibration) - 900
        #[prost(message, tag = "900")]
        RequestHvpSet(super::RequestHvpSet),
        #[prost(message, tag = "901")]
        RequestHvpStop(super::RequestHvpStop),
        #[prost(message, tag = "902")]
        RequestHvpStart(super::RequestHvpStart),
        #[prost(message, tag = "903")]
        RequestHvpStateGet(super::RequestHvpStateGet),
        /// HRPP - 920
        #[prost(message, tag = "920")]
        RequestHrppStart(super::RequestHrppStart),
        #[prost(message, tag = "921")]
        RequestHrppStop(super::RequestHrppStop),
        #[prost(message, tag = "922")]
        RequestHrppAmplitudeSet(super::RequestHrppAmplitudeSet),
        #[prost(message, tag = "923")]
        RequestHrppPlaybackSpeedSet(super::RequestHrppPlaybackSpeedSet),
        #[prost(message, tag = "924")]
        RequestHrppPatternSet(super::RequestHrppPatternSet),
        #[prost(message, tag = "925")]
        RequestHrppStateGet(super::RequestHrppStateGet),
        #[prost(message, tag = "926")]
        RequestHrppPatternsGet(super::RequestHrppPatternsGet),
    }
}
/// Responses are sent back individually as they are handled
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Requests {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<Request>,
}
/// Responses have the same ID as the request. NB! not all requests will have a result, and just return a blank response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
    #[prost(
        oneof = "response::Result",
        tags = "606, 620, 624, 700, 701, 709, 710, 712, 713, 714, 717, 720, 721, 723, 724, 725, 840, 841, 842, 843, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 900, 901, 902, 903, 920, 921, 922, 923, 924, 925, 926"
    )]
    pub result: ::core::option::Option<response::Result>,
}
/// Nested message and enum types in `Response`.
pub mod response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "606")]
        ResponseConnectionKeyGet(super::ResponseConnectionKeyGet),
        #[prost(message, tag = "620")]
        ResponseWifiStatusGet(super::ResponseWifiStatusGet),
        #[prost(message, tag = "624")]
        ResponseWifiScanResultsGet(super::ResponseWifiScanResultsGet),
        /// client public responses starts at 700 // \[PRIVATE\]
        #[prost(message, tag = "700")]
        ResponseModeGet(super::ResponseModeGet),
        #[prost(message, tag = "701")]
        ResponseModeSet(super::ResponseModeSet),
        #[prost(message, tag = "709")]
        ResponseClockOffsetSet(super::ResponseClockOffsetSet),
        #[prost(message, tag = "710")]
        ResponseBatteryGet(super::ResponseBatteryGet),
        #[prost(message, tag = "712")]
        ResponseClockOffsetGet(super::ResponseClockOffsetGet),
        #[prost(message, tag = "713")]
        ResponseCapabilitiesGet(super::ResponseCapabilitiesGet),
        #[prost(message, tag = "714")]
        ResponseSessionIdsGet(super::ResponseSessionIdsGet),
        /// Added in FW4.0.13
        #[prost(message, tag = "717")]
        ResponseConnectionModeGet(super::ResponseConnectionModeGet),
        /// HAMP - 720
        #[prost(message, tag = "720")]
        ResponseHampStart(super::ResponseHampStart),
        #[prost(message, tag = "721")]
        ResponseHampStop(super::ResponseHampStop),
        #[prost(message, tag = "723")]
        ResponseHampVelocitySet(super::ResponseHampVelocitySet),
        #[prost(message, tag = "724")]
        ResponseHampStateGet(super::ResponseHampStateGet),
        /// Added in FW4.0.15
        #[prost(message, tag = "725")]
        ResponseHampZoneSet(super::ResponseHampZoneSet),
        /// HDSP - 740
        /// Replies OK or ERROR only
        /// Slide - 840
        #[prost(message, tag = "840")]
        ResponseSliderStrokeGet(super::ResponseSliderStrokeGet),
        #[prost(message, tag = "841")]
        ResponseSliderStrokeSet(super::ResponseSliderStrokeSet),
        #[prost(message, tag = "842")]
        ResponseSliderStateGet(super::ResponseSliderStateGet),
        /// Added in FW4.0.15
        #[prost(message, tag = "843")]
        ResponseSliderCalibrate(super::ResponseSliderCalibrate),
        /// HSP - 860
        #[prost(message, tag = "860")]
        ResponseHspSetup(super::ResponseHspSetup),
        #[prost(message, tag = "861")]
        ResponseHspAdd(super::ResponseHspAdd),
        #[prost(message, tag = "862")]
        ResponseHspFlush(super::ResponseHspFlush),
        #[prost(message, tag = "863")]
        ResponseHspPlay(super::ResponseHspPlay),
        #[prost(message, tag = "864")]
        ResponseHspStop(super::ResponseHspStop),
        #[prost(message, tag = "865")]
        ResponseHspPause(super::ResponseHspPause),
        #[prost(message, tag = "866")]
        ResponseHspResume(super::ResponseHspResume),
        #[prost(message, tag = "867")]
        ResponseHspStateGet(super::ResponseHspStateGet),
        #[prost(message, tag = "868")]
        ResponseHspCurrentTimeSet(super::ResponseHspCurrentTimeSet),
        #[prost(message, tag = "869")]
        ResponseHspThresholdSet(super::ResponseHspThresholdSet),
        #[prost(message, tag = "870")]
        ResponseHspPauseOnStarvingSet(super::ResponseHspPauseOnStarvingSet),
        /// HVP - 900 (Vibration)
        #[prost(message, tag = "900")]
        ResponseHvpSet(super::ResponseHvpSet),
        #[prost(message, tag = "901")]
        ResponseHvpStop(super::ResponseHvpStop),
        #[prost(message, tag = "902")]
        ResponseHvpStart(super::ResponseHvpStart),
        #[prost(message, tag = "903")]
        ResponseHvpStateGet(super::ResponseHvpStateGet),
        /// HRPP - 920
        #[prost(message, tag = "920")]
        ResponseHrppStart(super::ResponseHrppStart),
        #[prost(message, tag = "921")]
        ResponseHrppStop(super::ResponseHrppStop),
        #[prost(message, tag = "922")]
        ResponseHrppAmplitudeSet(super::ResponseHrppAmplitudeSet),
        #[prost(message, tag = "923")]
        ResponseHrppPlaybackSpeedSet(super::ResponseHrppPlaybackSpeedSet),
        #[prost(message, tag = "924")]
        ResponseHrppPatternSet(super::ResponseHrppPatternSet),
        #[prost(message, tag = "925")]
        ResponseHrppStateGet(super::ResponseHrppStateGet),
        #[prost(message, tag = "926")]
        ResponseHrppPatternsGet(super::ResponseHrppPatternsGet),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Error {
    /// Handy Error code or ESP Error code
    #[prost(int32, tag = "1")]
    pub code: i32,
    /// A String providing a short description of the error. The message SHOULD be limited to a concise single sentence.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// A Primitive or Structured value that contains additional information about the error.
    #[prost(string, tag = "3")]
    pub data: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcMessage {
    #[prost(enumeration = "MessageType", tag = "1")]
    pub r#type: i32,
    #[prost(oneof = "rpc_message::Message", tags = "2, 3, 4, 5")]
    pub message: ::core::option::Option<rpc_message::Message>,
}
/// Nested message and enum types in `RpcMessage`.
pub mod rpc_message {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "2")]
        Request(super::Request),
        #[prost(message, tag = "3")]
        Requests(super::Requests),
        #[prost(message, tag = "4")]
        Response(super::Response),
        #[prost(message, tag = "5")]
        Notification(super::Notification),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageType {
    /// Must be there since enum starts with 0
    Unknown = 0,
    Request = 1,
    Requests = 2,
    Response = 3,
    Notification = 4,
}
impl MessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "MESSAGE_TYPE_UNKNOWN",
            Self::Request => "MESSAGE_TYPE_REQUEST",
            Self::Requests => "MESSAGE_TYPE_REQUESTS",
            Self::Response => "MESSAGE_TYPE_RESPONSE",
            Self::Notification => "MESSAGE_TYPE_NOTIFICATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGE_TYPE_UNKNOWN" => Some(Self::Unknown),
            "MESSAGE_TYPE_REQUEST" => Some(Self::Request),
            "MESSAGE_TYPE_REQUESTS" => Some(Self::Requests),
            "MESSAGE_TYPE_RESPONSE" => Some(Self::Response),
            "MESSAGE_TYPE_NOTIFICATION" => Some(Self::Notification),
            _ => None,
        }
    }
}
